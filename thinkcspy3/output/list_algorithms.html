
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>14. List Algorithms &#8212; How to Think Like a Computer Scientist: Learning with Python 3</title>
    <link rel="stylesheet" href="_static/style.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="copyright" title="Copyright" href="copyright.html" />
    <link rel="next" title="15. Classes and Objects — the Basics" href="classes_and_objects_I.html" />
    <link rel="prev" title="13. Files" href="files.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="classes_and_objects_I.html" title="15. Classes and Objects — the Basics"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="files.html" title="13. Files"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">How to Think Like a Computer Scientist: Learning with Python 3</a> &#187;</li> 
      </ul>
    </div>

    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <div class="line-block">
<div class="line"><br /></div>
</div>
<div class="section" id="list-algorithms">
<span id="index-0"></span><h1>14. List Algorithms<a class="headerlink" href="#list-algorithms" title="Permalink to this headline">¶</a></h1>
<p>This chapter is a bit different from what we’ve done so far: rather than
introduce more new Python syntax and features, we’re going to focus on
the program development process, and some algorithms that work with lists.</p>
<p>As in all parts of this book, our expectation is that you, the reader, will
copy our code into your Python environment, play and experiment, and work along with us.</p>
<p>Part of this chapter works with the
book <a class="reference download internal" href="_downloads/alice_in_wonderland.txt" download=""><code class="xref download docutils literal notranslate"><span class="pre">Alice</span> <span class="pre">in</span> <span class="pre">Wonderland</span></code></a> and a
<a class="reference download internal" href="_downloads/vocab.txt" download=""><code class="xref download docutils literal notranslate"><span class="pre">vocabulary</span> <span class="pre">file</span></code></a>.  Your browser should be able to download
and save these files from these links.</p>
<div class="section" id="test-driven-development">
<span id="index-1"></span><h2>14.1. Test-driven development<a class="headerlink" href="#test-driven-development" title="Permalink to this headline">¶</a></h2>
<p>Early in our <cite>Fruitful functions</cite> chapter we introduced the idea of
<em>incremental development</em>, where we added small fragments of
code to slowly build up the whole, so that we could easily find
problems early. Later in that same chapter we introduced <cite>unit testing</cite>
and gave code for our testing framework so that we could capture, in code,
appropriate tests for the functions we were writing.</p>
<p><strong>Test-driven development (TDD)</strong> is a software development practice which
takes these practices one step further.  The key idea is that automated
tests should be written <em>first</em>.  This technique is called <em>test-driven</em>
because — if we are to believe the extremists — non-testing code should
only be written when there is a failing test to make pass.</p>
<p>We can still retain our mode of working in small incremental steps, but
now we’ll define and express those steps in terms of a sequence of increasingly
sophisticated unit tests that demand more from our code at each stage.</p>
<p>We’ll turn our attention to some standard algorithms that process lists now, but
as we proceed through this chapter we’ll attempt to do so in the spirit envisaged
by TDD.</p>
</div>
<div class="section" id="the-linear-search-algorithm">
<span id="index-2"></span><h2>14.2. The linear search algorithm<a class="headerlink" href="#the-linear-search-algorithm" title="Permalink to this headline">¶</a></h2>
<p>We’d like to know the index where a specific item occurs within in a list of items.
Specifically, we’ll return the index of the item if it is found, or we’ll return
-1 if the item doesn’t occur in the list.  Let us start with some tests:</p>
<blockquote>
<div><div class="highlight-python3 notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">friends</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Joe&quot;</span><span class="p">,</span> <span class="s2">&quot;Zoe&quot;</span><span class="p">,</span> <span class="s2">&quot;Brad&quot;</span><span class="p">,</span> <span class="s2">&quot;Angelina&quot;</span><span class="p">,</span> <span class="s2">&quot;Zuki&quot;</span><span class="p">,</span> <span class="s2">&quot;Thandi&quot;</span><span class="p">,</span> <span class="s2">&quot;Paris&quot;</span><span class="p">]</span>
<span class="n">test</span><span class="p">(</span><span class="n">search_linear</span><span class="p">(</span><span class="n">friends</span><span class="p">,</span> <span class="s2">&quot;Zoe&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">test</span><span class="p">(</span><span class="n">search_linear</span><span class="p">(</span><span class="n">friends</span><span class="p">,</span> <span class="s2">&quot;Joe&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">test</span><span class="p">(</span><span class="n">search_linear</span><span class="p">(</span><span class="n">friends</span><span class="p">,</span> <span class="s2">&quot;Paris&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">6</span><span class="p">)</span>
<span class="n">test</span><span class="p">(</span><span class="n">search_linear</span><span class="p">(</span><span class="n">friends</span><span class="p">,</span> <span class="s2">&quot;Bill&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
</div></blockquote>
<p>Motivated by the fact that our tests don’t even run, let alone pass, we now write
the function:</p>
<blockquote>
<div><div class="highlight-python3 notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">search_linear</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Find and return the index of target in sequence xs &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">xs</span><span class="p">):</span>
       <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
           <span class="k">return</span> <span class="n">i</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</pre></div>
</td></tr></table></div>
</div></blockquote>
<p>There are a some points to learn here: We’ve seen a similar algorithm in section 8.10 when
we searched for a character in a string.  There we used a <code class="docutils literal notranslate"><span class="pre">while</span></code> loop, here we’ve used a
<code class="docutils literal notranslate"><span class="pre">for</span></code> loop, coupled with <code class="docutils literal notranslate"><span class="pre">enumerate</span></code> to extract the <code class="docutils literal notranslate"><span class="pre">(i,</span> <span class="pre">v)</span></code> pair on each iteration.
There are other variants — for example, we could have used <code class="docutils literal notranslate"><span class="pre">range</span></code> and made the loop
run only over the indexes, or we could have used the idiom of returning <code class="docutils literal notranslate"><span class="pre">None</span></code> when the
item was not found in the list.  But the essential similarity in all these variations is
that we test every item in the list in turn, from first to last, using the pattern of
the short-circuit <em>eureka traversal</em> that we introduced earlier —
that we return from the
function as soon as we find the target that we’re looking for.</p>
<p>Searching all items of a sequence from first to last is called a <strong>linear search</strong>.
Each time we check whether <code class="docutils literal notranslate"><span class="pre">v</span> <span class="pre">==</span> <span class="pre">target</span></code> we’ll call it a <strong>probe</strong>.  We like to count
probes as a measure of how efficient our algorithm is, and this will be a good enough
indication of how long our algorithm will take to execute.</p>
<p>Linear searching is characterized by the fact that the number of probes needed to find some
target depends directly on the length of the list. So if the list becomes ten times bigger,
we can expect to wait ten times longer when searching for things.
Notice too, that if we’re searching for a target
that is not present in the list, we’ll have to go all the way to the end before we can return
the negative value. So this case needs N probes, where N is the length of the list. However, if we’re
searching for a target that does exist in the list, we could be lucky
and find it immediately in position 0, or we might have to look further, perhaps even all
the way to the last item. On average, when the target is present, we’re going to need
to go about halfway through the list, or N/2 probes.</p>
<p>We say that this search has <strong>linear performance</strong> (linear meaning <cite>straight line</cite>) because,
if we were to measure the average search times for different sizes of lists (N), and then plot a graph
of time-to-search against N, we’d get a more-or-less straight line graph.</p>
<p>Analysis like this is pretty meaningless for small lists — the computer is quick enough
not to bother if the list only has a handful of items. So generally, we’re interested in
the <strong>scalability</strong> of our algorithms — how do they perform if we throw bigger problems at
them.  Would this search be a sensible one to use if we had a million or ten million
items (perhaps the catalog of books in your local library) in our list?  What happens
for really large datasets, e.g. how does Google search so brilliantly well?</p>
</div>
<div class="section" id="a-more-realistic-problem">
<h2>14.3. A more realistic problem<a class="headerlink" href="#a-more-realistic-problem" title="Permalink to this headline">¶</a></h2>
<p>As children learn to read, there are expectations that their vocabulary will grow.  So a
child of age 14 is expected to know more words than a child of age 8. When prescribing
reading books for a grade, an important question might be <em>“which words in this book
are not in the expected vocabulary at this level?”</em></p>
<p>Let us assume we can read a vocabulary of words into our program, and read the text
of a book, and split it into words.  Let us write some tests for what we need to do
next.  Test data can usually be very small, even if we intend to finally use our
program for larger cases:</p>
<blockquote>
<div><div class="highlight-python3 notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">vocab</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;apple&quot;</span><span class="p">,</span> <span class="s2">&quot;boy&quot;</span><span class="p">,</span> <span class="s2">&quot;dog&quot;</span><span class="p">,</span> <span class="s2">&quot;down&quot;</span><span class="p">,</span>
                          <span class="s2">&quot;fell&quot;</span><span class="p">,</span> <span class="s2">&quot;girl&quot;</span><span class="p">,</span> <span class="s2">&quot;grass&quot;</span><span class="p">,</span> <span class="s2">&quot;the&quot;</span><span class="p">,</span> <span class="s2">&quot;tree&quot;</span><span class="p">]</span>
<span class="n">book_words</span> <span class="o">=</span> <span class="s2">&quot;the apple fell from the tree to the grass&quot;</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
<span class="n">test</span><span class="p">(</span><span class="n">find_unknown_words</span><span class="p">(</span><span class="n">vocab</span><span class="p">,</span> <span class="n">book_words</span><span class="p">)</span> <span class="o">==</span> <span class="p">[</span><span class="s2">&quot;from&quot;</span><span class="p">,</span> <span class="s2">&quot;to&quot;</span><span class="p">])</span>
<span class="n">test</span><span class="p">(</span><span class="n">find_unknown_words</span><span class="p">([],</span> <span class="n">book_words</span><span class="p">)</span> <span class="o">==</span> <span class="n">book_words</span><span class="p">)</span>
<span class="n">test</span><span class="p">(</span><span class="n">find_unknown_words</span><span class="p">(</span><span class="n">vocab</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;the&quot;</span><span class="p">,</span> <span class="s2">&quot;boy&quot;</span><span class="p">,</span> <span class="s2">&quot;fell&quot;</span><span class="p">])</span> <span class="o">==</span> <span class="p">[])</span>
</pre></div>
</td></tr></table></div>
</div></blockquote>
<p>Notice we were a bit lazy, and used <code class="docutils literal notranslate"><span class="pre">split</span></code> to create our list of words —
it is easier than typing out the list, and very convenient if you want to input a
sentence into the program and turn it into a list of words.</p>
<p>We now need to implement the function for which we’ve written tests, and we’ll make
use of our linear search.  The basic strategy is to run through each of the words in
the book, look it up in the vocabulary, and if it is not in the vocabulary, save it
into a new resulting list which we return from the function:</p>
<blockquote>
<div><div class="highlight-python3 notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">find_unknown_words</span><span class="p">(</span><span class="n">vocab</span><span class="p">,</span> <span class="n">wds</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Return a list of words in wds that do not occur in vocab &quot;&quot;&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">wds</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">search_linear</span><span class="p">(</span><span class="n">vocab</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>
</pre></div>
</td></tr></table></div>
</div></blockquote>
<p>We can happily report now that the tests all pass.</p>
<p>Now let us look at the scalability.  We have more realistic vocabulary in the text file
that could be downloaded at the beginning of this chapter,
so let us read in the file (as a single string) and split it into a list of words. For
convenience, we’ll create a function to do this for us, and test it on a file we happen
to have available:</p>
<blockquote>
<div><div class="highlight-python3 notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">load_words_from_file</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Read words from filename, return list of words. &quot;&quot;&quot;</span>
    <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span>
    <span class="n">file_content</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
    <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">wds</span> <span class="o">=</span> <span class="n">file_content</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">wds</span>

<span class="n">bigger_vocab</span> <span class="o">=</span> <span class="n">load_words_from_file</span><span class="p">(</span><span class="s2">&quot;vocab.txt&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;There are </span><span class="si">{0}</span><span class="s2"> words in the vocab, starting with</span><span class="se">\n</span><span class="s2"> </span><span class="si">{1}</span><span class="s2"> &quot;</span>
              <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bigger_vocab</span><span class="p">),</span> <span class="n">bigger_vocab</span><span class="p">[:</span><span class="mi">6</span><span class="p">]))</span>
</pre></div>
</td></tr></table></div>
</div></blockquote>
<p>Python responds with:</p>
<blockquote>
<div><div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="go">There are 19469 words in the vocab, starting with</span>
<span class="go">[&#39;a&#39;, &#39;aback&#39;, &#39;abacus&#39;, &#39;abandon&#39;, &#39;abandoned&#39;, &#39;abandonment&#39;]</span>
</pre></div>
</div>
</div></blockquote>
<p>So we’ve got a more sensible size vocabulary. Now let us load up a book,
once again we’ll use the one we downloaded at the beginning of this chapter.
Loading a book is much like loading words from a file, but we’re going
to do a little extra black magic.  Books are full of punctuation, and have
mixtures of lowercase and uppercase letters.  We need to clean up the contents
of the book.  This will involve removing punctuation, and converting everything
to the same case (lowercase, because our vocabulary is all in lowercase).  So
we’ll want a more sophisticated way of converting text to words.</p>
<blockquote>
<div><div class="highlight-python3 notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">test</span><span class="p">(</span><span class="n">text_to_words</span><span class="p">(</span><span class="s2">&quot;My name is Earl!&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="p">[</span><span class="s2">&quot;my&quot;</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="s2">&quot;is&quot;</span><span class="p">,</span> <span class="s2">&quot;earl&quot;</span><span class="p">])</span>
<span class="n">test</span><span class="p">(</span><span class="n">text_to_words</span><span class="p">(</span><span class="s1">&#39;&quot;Well, I never!&quot;, said Alice.&#39;</span><span class="p">)</span> <span class="o">==</span>
                             <span class="p">[</span><span class="s2">&quot;well&quot;</span><span class="p">,</span> <span class="s2">&quot;i&quot;</span><span class="p">,</span> <span class="s2">&quot;never&quot;</span><span class="p">,</span> <span class="s2">&quot;said&quot;</span><span class="p">,</span> <span class="s2">&quot;alice&quot;</span><span class="p">])</span>
</pre></div>
</td></tr></table></div>
</div></blockquote>
<p>There is a powerful <code class="docutils literal notranslate"><span class="pre">translate</span></code> method available for strings.  The idea is that one sets up
desired substitutions — for every character, we can give a
corresponding replacement character.  The <code class="docutils literal notranslate"><span class="pre">translate</span></code> method will apply
these replacements throughout the whole string.  So here we go:</p>
<blockquote>
<div><div class="highlight-python3 notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">text_to_words</span><span class="p">(</span><span class="n">the_text</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; return a list of words with all punctuation removed,</span>
<span class="sd">        and all in lowercase.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">my_substitutions</span> <span class="o">=</span> <span class="n">the_text</span><span class="o">.</span><span class="n">maketrans</span><span class="p">(</span>
      <span class="c1"># If you find any of these</span>
      <span class="s2">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!</span><span class="se">\&quot;</span><span class="s2">#$%&amp;()*+,-./:;&lt;=&gt;?@[]^_`{|}~&#39;</span><span class="se">\\</span><span class="s2">&quot;</span><span class="p">,</span>
      <span class="c1"># Replace them by these</span>
      <span class="s2">&quot;abcdefghijklmnopqrstuvwxyz                                          &quot;</span><span class="p">)</span>

    <span class="c1"># Translate the text now.</span>
    <span class="n">cleaned_text</span> <span class="o">=</span> <span class="n">the_text</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">my_substitutions</span><span class="p">)</span>
    <span class="n">wds</span> <span class="o">=</span> <span class="n">cleaned_text</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">wds</span>
</pre></div>
</td></tr></table></div>
</div></blockquote>
<p>The translation turns all uppercase characters into lowercase, and all
punctuation characters and digits into spaces. Then, of course, <code class="docutils literal notranslate"><span class="pre">split</span></code>
will get rid of the spaces as it breaks the text into a list of words.  The tests pass.</p>
<p>Now we’re ready to read in our book:</p>
<blockquote>
<div><div class="highlight-python3 notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_words_in_book</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Read a book from filename, and return a list of its words. &quot;&quot;&quot;</span>
    <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span>
    <span class="n">content</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
    <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">wds</span> <span class="o">=</span> <span class="n">text_to_words</span><span class="p">(</span><span class="n">content</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wds</span>

<span class="n">book_words</span> <span class="o">=</span> <span class="n">get_words_in_book</span><span class="p">(</span><span class="s2">&quot;AliceInWonderland.txt&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;There are </span><span class="si">{0}</span><span class="s2"> words in the book, the first 100 are</span><span class="se">\n</span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span>
           <span class="nb">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">book_words</span><span class="p">),</span> <span class="n">book_words</span><span class="p">[:</span><span class="mi">100</span><span class="p">]))</span>
</pre></div>
</td></tr></table></div>
</div></blockquote>
<p>Python prints the following (all on one line, we’ve cheated a bit for the textbook):</p>
<blockquote>
<div><div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="go">There are 27336 words in the book, the first 100 are</span>
<span class="go">[&#39;alice&#39;, &#39;s&#39;, &#39;adventures&#39;, &#39;in&#39;, &#39;wonderland&#39;, &#39;lewis&#39;, &#39;carroll&#39;,</span>
<span class="go">    &#39;chapter&#39;, &#39;i&#39;, &#39;down&#39;, &#39;the&#39;, &#39;rabbit&#39;, &#39;hole&#39;, &#39;alice&#39;, &#39;was&#39;,</span>
<span class="go">    &#39;beginning&#39;, &#39;to&#39;, &#39;get&#39;, &#39;very&#39;, &#39;tired&#39;, &#39;of&#39;, &#39;sitting&#39;, &#39;by&#39;,</span>
<span class="go">    &#39;her&#39;, &#39;sister&#39;, &#39;on&#39;, &#39;the&#39;, &#39;bank&#39;, &#39;and&#39;, &#39;of&#39;, &#39;having&#39;,</span>
<span class="go">    &#39;nothing&#39;, &#39;to&#39;, &#39;do&#39;, &#39;once&#39;, &#39;or&#39;, &#39;twice&#39;, &#39;she&#39;, &#39;had&#39;,</span>
<span class="go">    &#39;peeped&#39;, &#39;into&#39;, &#39;the&#39;, &#39;book&#39;, &#39;her&#39;, &#39;sister&#39;, &#39;was&#39;, &#39;reading&#39;,</span>
<span class="go">    &#39;but&#39;, &#39;it&#39;, &#39;had&#39;, &#39;no&#39;, &#39;pictures&#39;, &#39;or&#39;, &#39;conversations&#39;, &#39;in&#39;,</span>
<span class="go">    &#39;it&#39;, &#39;and&#39;, &#39;what&#39;, &#39;is&#39;, &#39;the&#39;, &#39;use&#39;, &#39;of&#39;, &#39;a&#39;, &#39;book&#39;,</span>
<span class="go">    &#39;thought&#39;, &#39;alice&#39;, &#39;without&#39;, &#39;pictures&#39;, &#39;or&#39;, &#39;conversation&#39;,</span>
<span class="go">    &#39;so&#39;, &#39;she&#39;, &#39;was&#39;, &#39;considering&#39;, &#39;in&#39;, &#39;her&#39;, &#39;own&#39;, &#39;mind&#39;,</span>
<span class="go">    &#39;as&#39;, &#39;well&#39;, &#39;as&#39;, &#39;she&#39;, &#39;could&#39;, &#39;for&#39;, &#39;the&#39;, &#39;hot&#39;, &#39;day&#39;,</span>
<span class="go">    &#39;made&#39;, &#39;her&#39;, &#39;feel&#39;, &#39;very&#39;, &#39;sleepy&#39;, &#39;and&#39;, &#39;stupid&#39;,</span>
<span class="go">    &#39;whether&#39;, &#39;the&#39;, &#39;pleasure&#39;, &#39;of&#39;, &#39;making&#39;, &#39;a&#39;]</span>
</pre></div>
</div>
</div></blockquote>
<p>Well now we have all the pieces ready.  Let us see what words in this book are not in
the vocabulary:</p>
<blockquote>
<div><div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">missing_words</span> <span class="o">=</span> <span class="n">find_unknown_words</span><span class="p">(</span><span class="n">bigger_vocab</span><span class="p">,</span> <span class="n">book_words</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>We wait a considerable time now, something like a minute, before Python finally
works its way through this, and prints a list of 3398 words in the book that are
not in the vocabulary.  Mmm…  This is not particularly scaleable.  For a vocabulary
that is twenty times larger (you’ll often find school dictionaries with 300 000 words,
for example), and longer books, this is going to be slow.  So let us make some timing
measurements while we think about how we can improve this in the next section.</p>
<blockquote>
<div><div class="highlight-python3 notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">time</span>

<span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">clock</span><span class="p">()</span>
<span class="n">missing_words</span> <span class="o">=</span> <span class="n">find_unknown_words</span><span class="p">(</span><span class="n">bigger_vocab</span><span class="p">,</span> <span class="n">book_words</span><span class="p">)</span>
<span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">clock</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;There are </span><span class="si">{0}</span><span class="s2"> unknown words.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">missing_words</span><span class="p">)))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;That took </span><span class="si">{0:.4f}</span><span class="s2"> seconds.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">t1</span><span class="o">-</span><span class="n">t0</span><span class="p">))</span>
</pre></div>
</td></tr></table></div>
</div></blockquote>
<p>We get the results and some timing that we can refer back to later:</p>
<blockquote>
<div><div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="go">There are 3398 unknown words.</span>
<span class="go">That took 49.8014 seconds.</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="binary-search">
<span id="index-3"></span><h2>14.4. Binary Search<a class="headerlink" href="#binary-search" title="Permalink to this headline">¶</a></h2>
<p>If you think about what we’ve just done, it is not how we work in real life.
If you were given a vocabulary and asked to tell if some word was present,
you’d probably start in the middle. You can do this because the vocabulary
is ordered — so you can probe some word in the middle, and immediately realize
that your target was before (or perhaps after) the one you had probed.  Applying this
principle repeatedly leads us to a very much better algorithm for searching in a
list of items that are already ordered.  (Note that if the items are not ordered,
you have little choice other than to look through all of them.  But, if we know
the items are in order, we can improve our searching technique).</p>
<p>Lets start with some tests.  Remember, the list needs to be sorted:</p>
<blockquote>
<div><div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">xs</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">23</span><span class="p">,</span><span class="mi">29</span><span class="p">,</span><span class="mi">31</span><span class="p">,</span><span class="mi">37</span><span class="p">,</span><span class="mi">43</span><span class="p">,</span><span class="mi">47</span><span class="p">,</span><span class="mi">53</span><span class="p">]</span>
<span class="n">test</span><span class="p">(</span><span class="n">search_binary</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">test</span><span class="p">(</span><span class="n">search_binary</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="mi">99</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">test</span><span class="p">(</span><span class="n">search_binary</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">xs</span><span class="p">):</span>
    <span class="n">test</span><span class="p">(</span><span class="n">search_binary</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>Even our test cases are interesting this time: notice that we start
with items not in the list and look at boundary conditions — in the
middle of the list, less than all items in the list, bigger than the biggest.
Then we use a loop to use every list item as a target, and to confirm that our
binary search returns the corresponding index of that item in the list.</p>
<p>It is useful to think about having a <em>region-of-interest</em> (ROI) within the list being
searched.  This ROI will be the portion of the list in which it is still possible
that our target might be found.  Our algorithm will start with the ROI set to all
the items in the list. On the first probe in the middle of the ROI, there are
three possible outcomes: either we find the target, or we learn that we can
discard the top half of the ROI, or we learn that we can discard the bottom half
of the ROI.  And we keep doing this repeatedly, until we find our target, or until
we end up with no more items in our region of interest.  We can code this as follows:</p>
<blockquote>
<div><div class="highlight-python3 notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">search_binary</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Find and return the index of key in sequence xs &quot;&quot;&quot;</span>
    <span class="n">lb</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">ub</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">lb</span> <span class="o">==</span> <span class="n">ub</span><span class="p">:</span>   <span class="c1"># If region of interest (ROI) becomes empty</span>
           <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

        <span class="c1"># Next probe should be in the middle of the ROI</span>
        <span class="n">mid_index</span> <span class="o">=</span> <span class="p">(</span><span class="n">lb</span> <span class="o">+</span> <span class="n">ub</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>

        <span class="c1"># Fetch the item at that position</span>
        <span class="n">item_at_mid</span> <span class="o">=</span> <span class="n">xs</span><span class="p">[</span><span class="n">mid_index</span><span class="p">]</span>

        <span class="c1"># print(&quot;ROI[{0}:{1}](size={2}), probed=&#39;{3}&#39;, target=&#39;{4}&#39;&quot;</span>
        <span class="c1">#       .format(lb, ub, ub-lb, item_at_mid, target))</span>

        <span class="c1"># How does the probed item compare to the target?</span>
        <span class="k">if</span> <span class="n">item_at_mid</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mid_index</span>      <span class="c1"># Found it!</span>
        <span class="k">if</span> <span class="n">item_at_mid</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">:</span>
            <span class="n">lb</span> <span class="o">=</span> <span class="n">mid_index</span> <span class="o">+</span> <span class="mi">1</span>    <span class="c1"># Use upper half of ROI next time</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ub</span> <span class="o">=</span> <span class="n">mid_index</span>        <span class="c1"># Use lower half of ROI next time</span>
</pre></div>
</td></tr></table></div>
</div></blockquote>
<p>The region of interest is represented by two variables, a lower bound <code class="docutils literal notranslate"><span class="pre">lb</span></code>
and an upper bound <code class="docutils literal notranslate"><span class="pre">ub</span></code>.  It is important to be precise about what values
these indexes have.  We’ll make <code class="docutils literal notranslate"><span class="pre">lb</span></code> hold the index of the first item in the ROI, and
make <code class="docutils literal notranslate"><span class="pre">ub</span></code> hold the index just <em>beyond</em> the last item of interest.  So these semantics
are similar to a Python slice semantics: the region of interest is exactly the slice
<code class="docutils literal notranslate"><span class="pre">xs[lb:ub]</span></code>.  (The algorithm never actually takes any array slices!)</p>
<p>With this code in place, our tests pass.   Great.  Now if we substitute a call to this
search algorithm instead of calling the <code class="docutils literal notranslate"><span class="pre">search_linear</span></code> in <code class="docutils literal notranslate"><span class="pre">find_unknown_words</span></code>, can we
improve our performance?  Let’s do that, and again run this test:</p>
<blockquote>
<div><div class="highlight-python3 notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">clock</span><span class="p">()</span>
<span class="n">missing_words</span> <span class="o">=</span> <span class="n">find_unknown_words</span><span class="p">(</span><span class="n">bigger_vocab</span><span class="p">,</span> <span class="n">book_words</span><span class="p">)</span>
<span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">clock</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;There are </span><span class="si">{0}</span><span class="s2"> unknown words.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">missing_words</span><span class="p">)))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;That took </span><span class="si">{0:.4f}</span><span class="s2"> seconds.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">t1</span><span class="o">-</span><span class="n">t0</span><span class="p">))</span>
</pre></div>
</td></tr></table></div>
</div></blockquote>
<p>What a spectacular difference! More than 200 times faster!</p>
<blockquote>
<div><div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="go">There are 3398 unknown words.</span>
<span class="go">That took 0.2262 seconds.</span>
</pre></div>
</div>
</div></blockquote>
<p>Why is this binary search so much faster than the linear search?  If we uncomment
the print statement on lines 15 and 16, we’ll get a trace of the probes done during a
search.  Let’s go ahead, and try that:</p>
<blockquote>
<div><div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">search_binary</span><span class="p">(</span><span class="n">bigger_vocab</span><span class="p">,</span> <span class="s2">&quot;magic&quot;</span><span class="p">)</span>
<span class="go">ROI[0:19469](size=19469), probed=&#39;known&#39;, target=&#39;magic&#39;</span>
<span class="go">ROI[9735:19469](size=9734), probed=&#39;retailer&#39;, target=&#39;magic&#39;</span>
<span class="go">ROI[9735:14602](size=4867), probed=&#39;overthrow&#39;, target=&#39;magic&#39;</span>
<span class="go">ROI[9735:12168](size=2433), probed=&#39;mission&#39;, target=&#39;magic&#39;</span>
<span class="go">ROI[9735:10951](size=1216), probed=&#39;magnificent&#39;, target=&#39;magic&#39;</span>
<span class="go">ROI[9735:10343](size=608), probed=&#39;liken&#39;, target=&#39;magic&#39;</span>
<span class="go">ROI[10040:10343](size=303), probed=&#39;looks&#39;, target=&#39;magic&#39;</span>
<span class="go">ROI[10192:10343](size=151), probed=&#39;lump&#39;, target=&#39;magic&#39;</span>
<span class="go">ROI[10268:10343](size=75), probed=&#39;machete&#39;, target=&#39;magic&#39;</span>
<span class="go">ROI[10306:10343](size=37), probed=&#39;mafia&#39;, target=&#39;magic&#39;</span>
<span class="go">ROI[10325:10343](size=18), probed=&#39;magnanimous&#39;, target=&#39;magic&#39;</span>
<span class="go">ROI[10325:10334](size=9), probed=&#39;magical&#39;, target=&#39;magic&#39;</span>
<span class="go">ROI[10325:10329](size=4), probed= maggot&#39;, target=&#39;magic&#39;</span>
<span class="go">ROI[10328:10329](size=1), probed=&#39;magic&#39;, target=&#39;magic&#39;</span>
<span class="go">10328</span>
</pre></div>
</div>
</div></blockquote>
<p>Here we see that finding the target word “magic” needed just 14 probes before it was found
at index 10328.  The important thing is that each probe halves (with some truncation)
the remaining region of interest. By contrast, the linear search would have needed
10329 probes to find the same target word.</p>
<p>The word <em>binary</em> means <em>two</em>.  Binary search gets its name from the fact that each
probe splits the list into two pieces and discards the one half from the region of interest.</p>
<p>The beauty of the algorithm is that we could double the size of the vocabulary, and
it would only need one more probe!  And after another doubling, just another one probe.
So as the vocabulary gets bigger, this algorithm’s performance becomes even more
impressive.</p>
<p>Can we put a formula to this?   If our list size is N, what is the biggest number of
probes k we could need?  The maths is a bit easier if we turn the question around:
how big a list N could we deal with, given that we were only allowed to make k probes?</p>
<p>With 1 probe, we can only search a list of size 1.  With two probes we could cope with
lists up to size 3 - (test the middle item with the first probe, then test either the
left or right sublist with the second probe).  With one more probe, we could cope with 7 items (the
middle item, and two sublists of size 3).  With four probes, we can search 15 items,
and 5 probes lets us search up to 31 items.  So the general relationship is given by the formula</p>
<blockquote>
<div>N =  2<sup>k</sup> - 1</div></blockquote>
<p>where k is the number of probes we’re allowed to make, and N is
the maximum size of the list that can be searched in that many probes.   This function
is <em>exponential</em> in k (because k occurs in the exponent part).  If we wanted to
turn the formula around and solve for k in terms of N, we need to move the
constant 1 to the other side, and take a log (base 2) on each side. (The log is the
inverse of an exponent.)  So the formula for k in terms of N is now:</p>
<blockquote>
<div><img alt="_images/log2np1.png" src="_images/log2np1.png" />
</div></blockquote>
<p>The square-only-on-top brackets are called <em>ceiling brackets</em>: this means that you must round the
number up to the next whole integer.</p>
<p>Let us try this on a calculator, or in Python, which is the mother of all calculators:
suppose I have 1000 elements to be searched, what is the maximum number of probes I’ll need?
(There is a pesky +1 in the formula, so let us not forget to add it on…):</p>
<blockquote>
<div><div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">math</span> <span class="k">import</span> <span class="n">log</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">log</span><span class="p">(</span><span class="mi">1000</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">9.967226258835993</span>
</pre></div>
</div>
</div></blockquote>
<p>Telling us that we’ll need 9.96 probes maximum, to search 1000 items is not quite what we want.
We forgot to take the ceiling.  The <code class="docutils literal notranslate"><span class="pre">ceil</span></code> function in the <code class="docutils literal notranslate"><span class="pre">math</span></code>
module does exactly this.  So more accurately, now:</p>
<blockquote>
<div><div class="highlight-python3 notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">math</span> <span class="k">import</span> <span class="n">log</span><span class="p">,</span> <span class="n">ceil</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ceil</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="mi">1000</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ceil</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="mi">1000000</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ceil</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="mi">1000000000</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">30</span>
</pre></div>
</td></tr></table></div>
</div></blockquote>
<p>This tells us that searching 1000 items needs 10 probes. (Well technically, with 10
probes we can search exactly 1023 items, but the easy and useful stuff to
remember here is that “1000 items needs 10 probes, a million needs 20 probes,
and a billion items only needs 30 probes”).</p>
<p>You will rarely encounter algorithms that scale to large datasets as beautifully as binary search does!</p>
</div>
<div class="section" id="removing-adjacent-duplicates-from-a-list">
<span id="index-4"></span><h2>14.5. Removing adjacent duplicates from a list<a class="headerlink" href="#removing-adjacent-duplicates-from-a-list" title="Permalink to this headline">¶</a></h2>
<p>We often want to get the unique elements in a list, i.e. produce a new list in which each
different element occurs just once.  Consider our case of looking for words in Alice in Wonderland
that are not in our vocabulary.  We had a report that there are 3398 such words, but there
are duplicates in that list.  In fact, the word “alice” occurs 398 times
in the book, and it is not in our vocabulary!  How should we remove these duplicates?</p>
<p>A good approach is to sort the list, then remove all adjacent duplicates.  Let us start
with removing adjacent duplicates</p>
<blockquote>
<div><div class="highlight-python3 notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">test</span><span class="p">(</span><span class="n">remove_adjacent_dups</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">9</span><span class="p">])</span> <span class="o">==</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">9</span><span class="p">])</span>
<span class="n">test</span><span class="p">(</span><span class="n">remove_adjacent_dups</span><span class="p">([])</span> <span class="o">==</span> <span class="p">[])</span>
<span class="n">test</span><span class="p">(</span><span class="n">remove_adjacent_dups</span><span class="p">([</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;big&quot;</span><span class="p">,</span> <span class="s2">&quot;big&quot;</span><span class="p">,</span> <span class="s2">&quot;bite&quot;</span><span class="p">,</span> <span class="s2">&quot;dog&quot;</span><span class="p">])</span> <span class="o">==</span>
                                   <span class="p">[</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;big&quot;</span><span class="p">,</span> <span class="s2">&quot;bite&quot;</span><span class="p">,</span> <span class="s2">&quot;dog&quot;</span><span class="p">])</span>
</pre></div>
</td></tr></table></div>
</div></blockquote>
<p>The algorithm is easy and efficient.  We simply have to remember the most recent
item that was inserted into the result, and avoid inserting it again:</p>
<blockquote>
<div><div class="highlight-python3 notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">remove_adjacent_dups</span><span class="p">(</span><span class="n">xs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Return a new list in which all adjacent</span>
<span class="sd">        duplicates from xs have been removed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">most_recent_elem</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">xs</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">e</span> <span class="o">!=</span> <span class="n">most_recent_elem</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="n">most_recent_elem</span> <span class="o">=</span> <span class="n">e</span>

    <span class="k">return</span> <span class="n">result</span>
</pre></div>
</td></tr></table></div>
</div></blockquote>
<p>The amount of work done in this algorithm is linear — each item in <code class="docutils literal notranslate"><span class="pre">xs</span></code> causes the loop
to execute exactly once, and there are no nested loops.  So doubling the number of elements in
<code class="docutils literal notranslate"><span class="pre">xs</span></code> should cause this function to run twice as long: the relationship between the size of
the list and the time to run will be graphed as a straight (linear) line.</p>
<p>Let us go back now to our analysis of <cite>Alice in Wonderland</cite>.  Before checking the words in the
book against the vocabulary, we’ll sort those words into order, and eliminate duplicates.
So our new code looks like this:</p>
<blockquote>
<div><div class="highlight-python3 notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">all_words</span> <span class="o">=</span> <span class="n">get_words_in_book</span><span class="p">(</span><span class="s2">&quot;AliceInWonderland.txt&quot;</span><span class="p">)</span>
<span class="n">all_words</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
<span class="n">book_words</span> <span class="o">=</span> <span class="n">remove_adjacent_dups</span><span class="p">(</span><span class="n">all_words</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;There are </span><span class="si">{0}</span><span class="s2"> words in the book. Only </span><span class="si">{1}</span><span class="s2"> are unique.&quot;</span><span class="o">.</span>
                      <span class="nb">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">all_words</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">book_words</span><span class="p">)))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The first 100 words are</span><span class="se">\n</span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span>
           <span class="nb">format</span><span class="p">(</span><span class="n">book_words</span><span class="p">[:</span><span class="mi">100</span><span class="p">]))</span>
</pre></div>
</td></tr></table></div>
</div></blockquote>
<p>Almost magically, we get the following output:</p>
<blockquote>
<div><div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="go">There are 27336 words in the book. Only 2570 are unique.</span>
<span class="go">The first 100 words are</span>
<span class="go">[&#39;_i_&#39;, &#39;a&#39;, &#39;abide&#39;, &#39;able&#39;, &#39;about&#39;, &#39;above&#39;, &#39;absence&#39;, &#39;absurd&#39;,</span>
<span class="go"> &#39;acceptance&#39;, &#39;accident&#39;, &#39;accidentally&#39;, &#39;account&#39;, &#39;accounting&#39;,</span>
<span class="go"> &#39;accounts&#39;, &#39;accusation&#39;, &#39;accustomed&#39;, &#39;ache&#39;, &#39;across&#39;, &#39;act&#39;,</span>
<span class="go"> &#39;actually&#39;, &#39;ada&#39;, &#39;added&#39;, &#39;adding&#39;, &#39;addressed&#39;, &#39;addressing&#39;,</span>
<span class="go"> &#39;adjourn&#39;, &#39;adoption&#39;, &#39;advance&#39;, &#39;advantage&#39;, &#39;adventures&#39;,</span>
<span class="go"> &#39;advice&#39;, &#39;advisable&#39;, &#39;advise&#39;, &#39;affair&#39;, &#39;affectionately&#39;,</span>
<span class="go"> &#39;afford&#39;, &#39;afore&#39;, &#39;afraid&#39;, &#39;after&#39;, &#39;afterwards&#39;, &#39;again&#39;,</span>
<span class="go"> &#39;against&#39;, &#39;age&#39;, &#39;ago&#39;, &#39;agony&#39;, &#39;agree&#39;, &#39;ah&#39;, &#39;ahem&#39;, &#39;air&#39;,</span>
<span class="go"> &#39;airs&#39;, &#39;alarm&#39;, &#39;alarmed&#39;, &#39;alas&#39;, &#39;alice&#39;, &#39;alive&#39;, &#39;all&#39;,</span>
<span class="go"> &#39;allow&#39;, &#39;almost&#39;, &#39;alone&#39;, &#39;along&#39;, &#39;aloud&#39;, &#39;already&#39;, &#39;also&#39;,</span>
<span class="go"> &#39;altered&#39;, &#39;alternately&#39;, &#39;altogether&#39;, &#39;always&#39;, &#39;am&#39;, &#39;ambition&#39;,</span>
<span class="go"> &#39;among&#39;, &#39;an&#39;, &#39;ancient&#39;, &#39;and&#39;, &#39;anger&#39;, &#39;angrily&#39;, &#39;angry&#39;,</span>
<span class="go"> &#39;animal&#39;, &#39;animals&#39;, &#39;ann&#39;, &#39;annoy&#39;, &#39;annoyed&#39;, &#39;another&#39;,</span>
<span class="go"> &#39;answer&#39;, &#39;answered&#39;, &#39;answers&#39;, &#39;antipathies&#39;, &#39;anxious&#39;,</span>
<span class="go"> &#39;anxiously&#39;, &#39;any&#39;, &#39;anything&#39;, &#39;anywhere&#39;, &#39;appealed&#39;, &#39;appear&#39;,</span>
<span class="go"> &#39;appearance&#39;, &#39;appeared&#39;, &#39;appearing&#39;, &#39;applause&#39;, &#39;apple&#39;,</span>
<span class="go"> &#39;apples&#39;, &#39;arch&#39;]</span>
</pre></div>
</div>
</div></blockquote>
<p>Lewis Carroll was able to write a classic piece of literature
using only 2570 different words!</p>
</div>
<div class="section" id="merging-sorted-lists">
<span id="index-5"></span><h2>14.6. Merging sorted lists<a class="headerlink" href="#merging-sorted-lists" title="Permalink to this headline">¶</a></h2>
<p>Suppose we have two sorted lists. Devise an algorithm to merge them together into a single sorted list.</p>
<p>A simple but inefficient algorithm could be to simply append the two lists together,
and sort the result:</p>
<blockquote>
<div><div class="highlight-python3 notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">newlist</span> <span class="o">=</span> <span class="p">(</span><span class="n">xs</span> <span class="o">+</span> <span class="n">ys</span><span class="p">)</span>
<span class="n">newlist</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
</pre></div>
</td></tr></table></div>
</div></blockquote>
<p>But this doesn’t take advantage of the fact that the two lists are
already sorted, and is going to have poor scalability and performance for very large lists.</p>
<p>Lets get some tests together first:</p>
<blockquote>
<div><div class="highlight-python3 notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">xs</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">19</span><span class="p">]</span>
<span class="n">ys</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">24</span><span class="p">]</span>
<span class="n">zs</span> <span class="o">=</span> <span class="n">xs</span><span class="o">+</span><span class="n">ys</span>
<span class="n">zs</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
<span class="n">test</span><span class="p">(</span><span class="n">merge</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="p">[])</span> <span class="o">==</span> <span class="n">xs</span><span class="p">)</span>
<span class="n">test</span><span class="p">(</span><span class="n">merge</span><span class="p">([],</span> <span class="n">ys</span><span class="p">)</span> <span class="o">==</span> <span class="n">ys</span><span class="p">)</span>
<span class="n">test</span><span class="p">(</span><span class="n">merge</span><span class="p">([],</span> <span class="p">[])</span> <span class="o">==</span> <span class="p">[])</span>
<span class="n">test</span><span class="p">(</span><span class="n">merge</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">)</span> <span class="o">==</span> <span class="n">zs</span><span class="p">)</span>
<span class="n">test</span><span class="p">(</span><span class="n">merge</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span> <span class="o">==</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>
<span class="n">test</span><span class="p">(</span><span class="n">merge</span><span class="p">([</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;big&quot;</span><span class="p">,</span> <span class="s2">&quot;cat&quot;</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;big&quot;</span><span class="p">,</span> <span class="s2">&quot;bite&quot;</span><span class="p">,</span> <span class="s2">&quot;dog&quot;</span><span class="p">])</span> <span class="o">==</span>
               <span class="p">[</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;big&quot;</span><span class="p">,</span> <span class="s2">&quot;big&quot;</span><span class="p">,</span> <span class="s2">&quot;bite&quot;</span><span class="p">,</span> <span class="s2">&quot;cat&quot;</span><span class="p">,</span> <span class="s2">&quot;dog&quot;</span><span class="p">])</span>
</pre></div>
</td></tr></table></div>
</div></blockquote>
<p>Here is our merge algorithm:</p>
<blockquote>
<div><div class="highlight-python3 notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; merge sorted lists xs and ys. Return a sorted result &quot;&quot;&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">xi</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">yi</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">xi</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xs</span><span class="p">):</span>          <span class="c1"># If xs list is finished,</span>
            <span class="n">result</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">ys</span><span class="p">[</span><span class="n">yi</span><span class="p">:])</span> <span class="c1"># Add remaining items from ys</span>
            <span class="k">return</span> <span class="n">result</span>          <span class="c1"># And we&#39;re done.</span>

        <span class="k">if</span> <span class="n">yi</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ys</span><span class="p">):</span>          <span class="c1"># Same again, but swap roles</span>
            <span class="n">result</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="n">xi</span><span class="p">:])</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="c1"># Both lists still have items, copy smaller item to result.</span>
        <span class="k">if</span> <span class="n">xs</span><span class="p">[</span><span class="n">xi</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">ys</span><span class="p">[</span><span class="n">yi</span><span class="p">]:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="n">xi</span><span class="p">])</span>
            <span class="n">xi</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ys</span><span class="p">[</span><span class="n">yi</span><span class="p">])</span>
            <span class="n">yi</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</td></tr></table></div>
</div></blockquote>
<p>The algorithm works as follows: we create a result list, and keep two indexes,
one into each list (lines 3-5).  On each iteration of the loop, whichever list item is smaller
is copied to the result list, and that list’s index is advanced.  As soon as either index
reaches the end of its list, we copy all the remaining items from the other list
into the result, which we return.</p>
</div>
<div class="section" id="alice-in-wonderland-again">
<h2>14.7. Alice in Wonderland, again!<a class="headerlink" href="#alice-in-wonderland-again" title="Permalink to this headline">¶</a></h2>
<p>Underlying the algorithm for merging sorted lists is a deep pattern of computation that
is widely reusable.  The pattern essence is <em>“Run through the lists always processing the
smallest remaining items from each, with these cases to consider:”</em></p>
<ul class="simple">
<li>What should we do when either list has no more items?</li>
<li>What should we do if the smallest items from each list are equal to each other?</li>
<li>What should we do if the smallest item in the first list is smaller than the smallest one the second list?</li>
<li>What should we do in the remaining case?</li>
</ul>
<p>Lets assume we have two sorted lists.  Exercise your algorithmic skills by adapting
the merging algorithm pattern for each of these cases:</p>
<ul class="simple">
<li>Return only those items that are present in both lists.</li>
<li>Return only those items that are present in the first list, but not in the second.</li>
<li>Return only those items that are present in the second list, but not in the first.</li>
<li>Return items that are present in either the first or the second list.</li>
<li>Return items from the first list that are not eliminated by a matching element
in the second list.  In this case, an item in the second list “knocks out” just one
matching item in the first list.  This operation is sometimes called <em>bagdiff</em>.
For example  <code class="docutils literal notranslate"><span class="pre">bagdiff([5,7,11,11,11,12,13],</span> <span class="pre">[7,8,11])</span></code> would return  <code class="docutils literal notranslate"><span class="pre">[5,11,11,12,13]</span></code></li>
</ul>
<p>In the previous section we sorted the words from the book, and eliminated duplicates.
Our vocabulary is also sorted.  So third case above — find all items in the second list
that are not in the first list, would be another way to implement <code class="docutils literal notranslate"><span class="pre">find_unknown_words</span></code>.
Instead of searching for every word in the dictionary (either by linear or binary search),
why not use a variant of the merge to return the words that occur in the book, but not in
the vocabulary.</p>
<blockquote>
<div><div class="highlight-python3 notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">find_unknowns_merge_pattern</span><span class="p">(</span><span class="n">vocab</span><span class="p">,</span> <span class="n">wds</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Both the vocab and wds must be sorted.  Return a new</span>
<span class="sd">        list of words from wds that do not occur in vocab.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">xi</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">yi</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">xi</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vocab</span><span class="p">):</span>
            <span class="n">result</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">wds</span><span class="p">[</span><span class="n">yi</span><span class="p">:])</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="k">if</span> <span class="n">yi</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">wds</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="k">if</span> <span class="n">vocab</span><span class="p">[</span><span class="n">xi</span><span class="p">]</span> <span class="o">==</span> <span class="n">wds</span><span class="p">[</span><span class="n">yi</span><span class="p">]:</span>  <span class="c1"># Good, word exists in vocab</span>
            <span class="n">yi</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">elif</span> <span class="n">vocab</span><span class="p">[</span><span class="n">xi</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">wds</span><span class="p">[</span><span class="n">yi</span><span class="p">]:</span> <span class="c1"># Move past this vocab word,</span>
            <span class="n">xi</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">else</span><span class="p">:</span>                     <span class="c1"># Got word that is not in vocab</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wds</span><span class="p">[</span><span class="n">yi</span><span class="p">])</span>
            <span class="n">yi</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</td></tr></table></div>
</div></blockquote>
<p>Now we put it all together:</p>
<blockquote>
<div><div class="highlight-python3 notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">all_words</span> <span class="o">=</span> <span class="n">get_words_in_book</span><span class="p">(</span><span class="s2">&quot;AliceInWonderland.txt&quot;</span><span class="p">)</span>
<span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">clock</span><span class="p">()</span>
<span class="n">all_words</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
<span class="n">book_words</span> <span class="o">=</span> <span class="n">remove_adjacent_dups</span><span class="p">(</span><span class="n">all_words</span><span class="p">)</span>
<span class="n">missing_words</span> <span class="o">=</span> <span class="n">find_unknowns_merge_pattern</span><span class="p">(</span><span class="n">bigger_vocab</span><span class="p">,</span> <span class="n">book_words</span><span class="p">)</span>
<span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">clock</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;There are </span><span class="si">{0}</span><span class="s2"> unknown words.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">missing_words</span><span class="p">)))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;That took </span><span class="si">{0:.4f}</span><span class="s2"> seconds.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">t1</span><span class="o">-</span><span class="n">t0</span><span class="p">))</span>
</pre></div>
</td></tr></table></div>
</div></blockquote>
<p>Even more stunning performance here:</p>
<blockquote>
<div><div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="go">There are 828 unknown words.</span>
<span class="go">That took 0.0410 seconds.</span>
</pre></div>
</div>
</div></blockquote>
<p>Let’s review what we’ve done. We started with a word-by-word linear lookup in the vocabulary
that ran in about 50 seconds.  We implemented a clever binary search,
and got that down to 0.22 seconds, more than 200 times faster.
But then we did something even better: we sorted the
words from the book, eliminated duplicates, and used a merging pattern to find
words from the book that were not in the dictionary.  This was about five times
faster than even the binary lookup algorithm.  At the end of the chapter our
algorithm is more than a 1000 times faster than our first attempt!</p>
<p>That is what we can call a good day at the office!</p>
<span class="target" id="eightqueenssolver"></span></div>
<div class="section" id="eight-queens-puzzle-part-1">
<span id="index-6"></span><h2>14.8. Eight Queens puzzle, part 1<a class="headerlink" href="#eight-queens-puzzle-part-1" title="Permalink to this headline">¶</a></h2>
<p>As told by Wikipedia, <em>“The eight queens puzzle is the problem of placing eight chess
queens on an 8x8 chessboard so that no two queens attack each other. Thus, a
solution requires that no two queens share the same row, column, or diagonal.”</em></p>
<blockquote>
<div><img alt="_images/eight_queens_01.png" src="_images/eight_queens_01.png" />
</div></blockquote>
<p>Please try this yourself, and find a few more solutions by hand.</p>
<p>We’d like to write a program to find solutions to this puzzle.  In fact,
the puzzle generalizes to placing N queens on an NxN board, so we’re going to
think about the general case, not just the 8x8 case.  Perhaps we can find solutions
for 12 queens on a 12x12 board, or 20 queens on a 20x20 board.</p>
<p>How do we approach a complex problem like this?  A good starting point is to think
about our <em>data structures</em> — how exactly do we plan to represent the state of
the chessboard and its queens in our program?  Once we have some handle on what
our puzzle is going to look like in memory, we can begin to think about the functions
and logic we’ll need to solve the puzzle, i.e. how do we put another queen onto the board
somewhere, and to check whether it clashes with any of the queens already on the board.</p>
<p>The steps of finding a good representation, and then finding a good algorithm to operate on
the data cannot always be done independently of each other.  As you think about the operations
you require, you may want to change or reorganize the data somewhat to make it easier
to do the operations you need.</p>
<p>This relationship between algorithms and data was elegantly expressed in the title
of a book <em>Algorithms + Data Structures = Programs</em>, written by one of the pioneers in
Computer Science, Niklaus Wirth, the inventor of Pascal.</p>
<p>Let’s brainstorm some ideas about how a chessboard and queens could be represented in memory.</p>
<ul>
<li><p class="first">A two dimensional matrix (a list of 8 lists, each containing 8 squares) is one possibility.
At each square of the board would like to know whether it contains a queen or not — just two
possible states for each square — so perhaps each element in the lists could be True or False,
or, more simply, 0 or 1.</p>
<p>Our state for the solution above could then have this data representation:</p>
<blockquote>
<div><div class="highlight-python3 notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">bd1</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
       <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]]</span>
</pre></div>
</td></tr></table></div>
</div></blockquote>
<p>You should also be able to see how the empty board would be represented, and you should start
to imagine what operations or changes you’d need to make to the data to place another
queen somewhere on the board.</p>
</li>
<li><p class="first">Another idea might be to keep a list of coordinates of
where the queens are.  Using the notation in
the illustration, for example, we could represent the state of that solution as:</p>
<blockquote>
<div><div class="highlight-python3 notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">bd2</span> <span class="o">=</span> <span class="p">[</span> <span class="s2">&quot;a6&quot;</span><span class="p">,</span> <span class="s2">&quot;b4&quot;</span><span class="p">,</span> <span class="s2">&quot;c2&quot;</span><span class="p">,</span> <span class="s2">&quot;d0&quot;</span><span class="p">,</span> <span class="s2">&quot;e5&quot;</span><span class="p">,</span> <span class="s2">&quot;f7&quot;</span><span class="p">,</span> <span class="s2">&quot;g1&quot;</span><span class="p">,</span> <span class="s2">&quot;h3&quot;</span> <span class="p">]</span>
</pre></div>
</td></tr></table></div>
</div></blockquote>
</li>
<li><p class="first">We could make other tweaks to this — perhaps each
element in this list should rather be a tuple, with
integer coordinates for both axes.  And being good computer scientists, we’d probably start numbering
each axis from 0 instead of at 1. Now our representation could be:</p>
<blockquote>
<div><div class="highlight-python3 notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">bd3</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">),</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">3</span><span class="p">)]</span>
</pre></div>
</td></tr></table></div>
</div></blockquote>
</li>
<li><p class="first">Looking at this representation, we can’t help but notice that the first coordinates
are <code class="docutils literal notranslate"><span class="pre">0,1,2,3,4,5,6,7</span></code> and they correspond exactly to the index position of the
pairs in the list.  So we could discard them, and come up with this really compact
alternative representation of the solution:</p>
<blockquote>
<div><div class="highlight-python3 notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">bd4</span> <span class="o">=</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</pre></div>
</td></tr></table></div>
</div></blockquote>
<p>This will be what we’ll use, let’s see where that takes us.</p>
</li>
</ul>
<blockquote>
<div><div class="admonition-this-representation-is-not-general admonition">
<p class="first admonition-title">This representation is not general</p>
<p>We’ve come up with a great representation. But will it work for other puzzles?
Our list representation has the constraint that one can only put
one queen in each column. But that is a puzzle constraint anyway — no two queens are
allowed to share the same column.  So puzzle and data representation are well matched.</p>
<p class="last">But if we were trying to solve a different puzzle on a chessboard, perhaps
play a game of checkers, where many pieces could occupy the same column, our
representation would not work.</p>
</div>
</div></blockquote>
<p>Let us now take some grand insight into the problem.  Do you think it is a coincidence
that there are no repeated numbers in the solution?  The solution  <code class="docutils literal notranslate"><span class="pre">[6,4,2,0,5,7,1,3]</span></code>
contains the numbers <code class="docutils literal notranslate"><span class="pre">0,1,2,3,4,5,6,7</span></code>, but none are duplicated!  Could other
solutions contain duplicate numbers, or not?</p>
<p>A little thinking should convince you that there can never be duplicate numbers in a
solution: the numbers represent the row on which the queen is placed, and because we are
never permitted to put two queens in the same row, no solution will ever have
duplicate row numbers in it.</p>
<blockquote>
<div><div class="admonition-our-key-insight admonition">
<p class="first admonition-title">Our key insight</p>
<p class="last"><em>In our representation, any solution to the N queens problem must therefore be a permutation of the numbers [0 .. N-1].</em></p>
</div>
</div></blockquote>
<p>Note that not all permutations are solutions.  For example, <code class="docutils literal notranslate"><span class="pre">[0,1,2,3,4,5,6,7]</span></code> has all
queens on the same diagonal.</p>
<p>Wow, we seem to be making progress on this problem merely by thinking, rather than coding!</p>
<p>Our algorithm should start taking shape now.  We can start with the list [0..N-1],
generate various permutations of that list, and check each permutation to see if it
has any clashes (queens that are on the same diagonal).  If it has no clashes, it is
a solution, and we can print it.</p>
<p>Let us be precise and clear on this issue: if we only use permutations of the rows, and we’re
using our compact representation, no queens can clash on either rows or columns, and we don’t
even have to concern ourselves with those cases.  So the only clashes we need
to test for are clashes on the diagonals.</p>
<p>It sounds like a useful function will be one that can test if two queens
share a diagonal.  Each queen is on some (x,y) position.
So does the queen at (5,2) share a diagonal with the one at (2,0)?
Does (5,2) clash with (3,0)?</p>
<blockquote>
<div><div class="highlight-python3 notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">test</span><span class="p">(</span><span class="ow">not</span> <span class="n">share_diagonal</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
<span class="n">test</span><span class="p">(</span><span class="n">share_diagonal</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
<span class="n">test</span><span class="p">(</span><span class="n">share_diagonal</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="n">test</span><span class="p">(</span><span class="n">share_diagonal</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</td></tr></table></div>
</div></blockquote>
<p>A little geometry will help us here.
A diagonal has a slope of either 1 or -1.  The question we really want to
ask is <em>is their distance between them the same in the x and the y direction?</em>
If it is, they share a diagonal.   Because diagonals can be to the left
or right, it will make sense for this program to use the absolute distance
in each direction:</p>
<blockquote>
<div><div class="highlight-python3 notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">share_diagonal</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Is (x0, y0) on a shared diagonal with (x1, y1)? &quot;&quot;&quot;</span>
    <span class="n">dy</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">y1</span> <span class="o">-</span> <span class="n">y0</span><span class="p">)</span>        <span class="c1"># Calc the absolute y distance</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x1</span> <span class="o">-</span> <span class="n">x0</span><span class="p">)</span>        <span class="c1"># CXalc the absolute x distance</span>
    <span class="k">return</span> <span class="n">dx</span> <span class="o">==</span> <span class="n">dy</span>          <span class="c1"># They clash if dx == dy</span>
</pre></div>
</td></tr></table></div>
</div></blockquote>
<p>If you copy the code and run it, you’ll be happy to learn that the tests pass!</p>
<p>Now let’s consider how we construct a solution by hand.  We’ll put a queen
somewhere in the first column, then place one in the second column, only if it
does not clash with the one already on the board.  And then we’ll put a third
one on, checking it against the two queens already to its left. When we consider
the queen on column 6, we’ll need to check for clashes against those in all
the columns to its left, i.e. in columns 0,1,2,3,4,5.</p>
<p>So the next building block is a function that, given a partially completed
puzzle, can check whether the queen at column <code class="docutils literal notranslate"><span class="pre">c</span></code> clashes with any of the
queens to its left, at columns 0,1,2,..c-1:</p>
<blockquote>
<div><div class="highlight-python3 notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1"># Solutions cases that should not have any clashes</span>
<span class="n">test</span><span class="p">(</span><span class="ow">not</span> <span class="n">col_clashes</span><span class="p">([</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="mi">4</span><span class="p">))</span>
<span class="n">test</span><span class="p">(</span><span class="ow">not</span> <span class="n">col_clashes</span><span class="p">([</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">7</span><span class="p">))</span>

<span class="c1"># More test cases that should mostly clash</span>
<span class="n">test</span><span class="p">(</span><span class="n">col_clashes</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">))</span>
<span class="n">test</span><span class="p">(</span><span class="n">col_clashes</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="mi">1</span><span class="p">))</span>
<span class="n">test</span><span class="p">(</span><span class="n">col_clashes</span><span class="p">([</span><span class="mi">6</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="mi">1</span><span class="p">))</span>
<span class="n">test</span><span class="p">(</span><span class="n">col_clashes</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">3</span><span class="p">))</span>
<span class="n">test</span><span class="p">(</span><span class="n">col_clashes</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">7</span><span class="p">],</span> <span class="mi">2</span><span class="p">))</span>
<span class="n">test</span><span class="p">(</span><span class="ow">not</span> <span class="n">col_clashes</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">))</span>
<span class="n">test</span><span class="p">(</span><span class="n">col_clashes</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="mi">2</span><span class="p">))</span>
</pre></div>
</td></tr></table></div>
</div></blockquote>
<p>Here is our function that makes them all pass:</p>
<blockquote>
<div><div class="highlight-python3 notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">col_clashes</span><span class="p">(</span><span class="n">bs</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Return True if the queen at column c clashes</span>
<span class="sd">         with any queen to its left.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>     <span class="c1"># Look at all columns to the left of c</span>
          <span class="k">if</span> <span class="n">share_diagonal</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">bs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">c</span><span class="p">,</span> <span class="n">bs</span><span class="p">[</span><span class="n">c</span><span class="p">]):</span>
              <span class="k">return</span> <span class="kc">True</span>

    <span class="k">return</span> <span class="kc">False</span>           <span class="c1"># No clashes - col c has a safe placement.</span>
</pre></div>
</td></tr></table></div>
</div></blockquote>
<p>Finally, we’re going to give our program one of our permutations — i.e.
all queens placed somewhere, one on each row, one on each column.  But does
the permutation have any diagonal clashes?</p>
<blockquote>
<div><div class="highlight-python3 notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">test</span><span class="p">(</span><span class="ow">not</span> <span class="n">has_clashes</span><span class="p">([</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]))</span> <span class="c1"># Solution from above</span>
<span class="n">test</span><span class="p">(</span><span class="n">has_clashes</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]))</span>     <span class="c1"># Swap rows of first two</span>
<span class="n">test</span><span class="p">(</span><span class="n">has_clashes</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]))</span>             <span class="c1"># Try small 4x4 board</span>
<span class="n">test</span><span class="p">(</span><span class="ow">not</span> <span class="n">has_clashes</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>         <span class="c1"># Solution to 4x4 case</span>
</pre></div>
</td></tr></table></div>
</div></blockquote>
<p>And the code to make the tests pass:</p>
<blockquote>
<div><div class="highlight-python3 notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">has_clashes</span><span class="p">(</span><span class="n">the_board</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Determine whether we have any queens clashing on the diagonals.</span>
<span class="sd">        We&#39;re assuming here that the_board is a permutation of column</span>
<span class="sd">        numbers, so we&#39;re not explicitly checking row or column clashes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">the_board</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">col_clashes</span><span class="p">(</span><span class="n">the_board</span><span class="p">,</span> <span class="n">col</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="kc">False</span>
</pre></div>
</td></tr></table></div>
</div></blockquote>
<p>Summary of what we’ve done so far:  we now have a powerful function called <code class="docutils literal notranslate"><span class="pre">has_clashes</span></code> that can
tell if a configuration is a solution to the queens puzzle.   Let’s get on now with generating
lots of permutations and finding solutions!</p>
</div>
<div class="section" id="eight-queens-puzzle-part-2">
<span id="eightqueensmainprog"></span><h2>14.9. Eight Queens puzzle, part 2<a class="headerlink" href="#eight-queens-puzzle-part-2" title="Permalink to this headline">¶</a></h2>
<p>This is the fun, easy part.  We could try to find all permutations of <code class="docutils literal notranslate"><span class="pre">[0,1,2,3,4,5,6,7]</span></code> — that
might be algorithmically challenging, and would be a <em>brute force</em> way of tackling the
problem.  We just try everything, and find all possible solutions.</p>
<p>Of course we know there are N! permutations of N things, so we can get an early idea of
how long it would take to search all of them for all solutions.  Not too long at all, actually -
8! is only 40320 different cases to check out.  This is vastly better than starting with
64 places to put eight queens.  If you
do the sums for how many ways can you choose 8 of the 64 squares for your queens, the
formula (called <em>N choose k</em> where you’re choosing k=8 squares of the available N=64)
yields a whopping 4426165368, obtained from (64! / (8! x 56!)).</p>
<p>So our earlier key insight — that we only need to consider permutations —
has reduced what we call the <em>problem space</em> from about 4.4 billion cases to just 40320!</p>
<p>We’re not even going to explore all those, however.  When we introduced the random number
module, we learned that it had a <code class="docutils literal notranslate"><span class="pre">shuffle</span></code> method that randomly permuted a list of items.
So we’re going to write a “random” algorithm to find solutions to the N queens
problem.  We’ll begin with the permutation [0,1,2,3,4,5,6,7] and we’ll repeatedly shuffle
the list, and test each to see if it works!  Along the way we’ll count how many attempts
we need before we find each solution, and we’ll find 10 solutions  (we could hit the same
solution more than once, because shuffle is random!):</p>
<blockquote>
<div><div class="highlight-python3 notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="kn">import</span> <span class="nn">random</span>
    <span class="n">rng</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">Random</span><span class="p">()</span>   <span class="c1"># Instantiate a generator</span>

    <span class="n">bd</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span>     <span class="c1"># Generate the initial permutation</span>
    <span class="n">num_found</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">tries</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">num_found</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
       <span class="n">rng</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">bd</span><span class="p">)</span>
       <span class="n">tries</span> <span class="o">+=</span> <span class="mi">1</span>
       <span class="k">if</span> <span class="ow">not</span> <span class="n">has_clashes</span><span class="p">(</span><span class="n">bd</span><span class="p">):</span>
           <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Found solution </span><span class="si">{0}</span><span class="s2"> in </span><span class="si">{1}</span><span class="s2"> tries.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">bd</span><span class="p">,</span> <span class="n">tries</span><span class="p">))</span>
           <span class="n">tries</span> <span class="o">=</span> <span class="mi">0</span>
           <span class="n">num_found</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="n">main</span><span class="p">()</span>
</pre></div>
</td></tr></table></div>
</div></blockquote>
<p>Almost magically, and at great speed, we get this:</p>
<blockquote>
<div><div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="go">Found solution [3, 6, 2, 7, 1, 4, 0, 5] in 693 tries.</span>
<span class="go">Found solution [5, 7, 1, 3, 0, 6, 4, 2] in 82 tries.</span>
<span class="go">Found solution [3, 0, 4, 7, 1, 6, 2, 5] in 747 tries.</span>
<span class="go">Found solution [1, 6, 4, 7, 0, 3, 5, 2] in 428 tries.</span>
<span class="go">Found solution [6, 1, 3, 0, 7, 4, 2, 5] in 376 tries.</span>
<span class="go">Found solution [3, 0, 4, 7, 5, 2, 6, 1] in 204 tries.</span>
<span class="go">Found solution [4, 1, 7, 0, 3, 6, 2, 5] in 98 tries.</span>
<span class="go">Found solution [3, 5, 0, 4, 1, 7, 2, 6] in 64 tries.</span>
<span class="go">Found solution [5, 1, 6, 0, 3, 7, 4, 2] in 177 tries.</span>
<span class="go">Found solution [1, 6, 2, 5, 7, 4, 0, 3] in 478 tries.</span>
</pre></div>
</div>
</div></blockquote>
<p>Here is an interesting fact.  On an 8x8 board,
there are known to be 92 different solutions to this puzzle.
We are randomly picking one of 40320 possible permutations of our representation.
So our chances of picking a solution on each try are 92/40320.  Put another way,
on average we’ll need 40320/92 tries — about 438.26 —
before we stumble across a solution.  The number of tries we printed looks
like our experimental data agrees quite nicely with our theory!</p>
<div class="admonition-save-this-code-for-later admonition">
<p class="first admonition-title">Save this code for later.</p>
<p class="last">In the chapter on PyGame we plan to write a module to draw the board
with its queens, and integrate that module with this code.</p>
</div>
</div>
<div class="section" id="glossary">
<h2>14.10. Glossary<a class="headerlink" href="#glossary" title="Permalink to this headline">¶</a></h2>
<dl class="glossary docutils">
<dt id="term-binary-search">binary search</dt>
<dd>A famous algorithm that searches for a target in a sorted list.  Each probe in the
list allows us to discard half the remaining items, so the algorithm is very efficient.</dd>
<dt id="term-linear">linear</dt>
<dd>Relating to a straight line.  Here, we talk about graphing how the time taken by an
algorithm depends on the size of the data it is processing.  Linear algorithms have
straight-line graphs that can describe this relationship.</dd>
<dt id="term-linear-search">linear search</dt>
<dd>A search that probes each item in a list or sequence, from first, until it finds
what it is looking for.  It is used for searching for a target in unordered lists of items.</dd>
<dt id="term-merge-algorithm">Merge algorithm</dt>
<dd>An efficient algorithm that merges two already sorted lists, to produce a sorted list result.
The merge algorithm is really a pattern of computation that can be adapted and reused for
various other scenarios, such as finding words that are in a book, but not in a vocabulary.</dd>
<dt id="term-probe">probe</dt>
<dd>Each time we take a look when searching for an item is called a probe.  In our
chapter on <cite>Iteration</cite> we also played a guessing game where the computer tried
to guess the user’s secret number. Each of those tries would also be called a probe.</dd>
<dt id="term-test-driven-development-tdd">test-driven development (TDD)</dt>
<dd>A software development practice which arrives at a desired feature
through a series of small, iterative steps motivated by automated tests
which are <em>written first</em> that express increasing refinements of the
desired feature.  (see the Wikipedia article on <a class="reference external" href="http://en.wikipedia.org/wiki/Test_driven_development">Test-driven
development</a>
for more information.)</dd>
</dl>
</div>
<div class="section" id="exercises">
<h2>14.11. Exercises<a class="headerlink" href="#exercises" title="Permalink to this headline">¶</a></h2>
<ol class="arabic">
<li><p class="first">The section in this chapter called <a class="reference internal" href="#alice-in-wonderland-again">Alice in Wonderland, again!</a> started with the
observation that the merge algorithm uses a pattern that can be reused
in other situations.  Adapt the merge algorithm to write each of these functions,
as was suggested there:</p>
<blockquote>
<div><ol class="loweralpha simple">
<li>Return only those items that are present in both lists.</li>
<li>Return only those items that are present in the first list, but not in the second.</li>
<li>Return only those items that are present in the second list, but not in the first.</li>
<li>Return items that are present in either the first or the second list.</li>
<li>Return items from the first list that are not eliminated by a matching element
in the second list.  In this case, an item in the second list “knocks out” just one
matching item in the first list.  This operation is sometimes called <em>bagdiff</em>.
For example  <code class="docutils literal notranslate"><span class="pre">bagdiff([5,7,11,11,11,12,13],</span> <span class="pre">[7,8,11])</span></code> would return  <code class="docutils literal notranslate"><span class="pre">[5,11,11,12,13]</span></code></li>
</ol>
</div></blockquote>
</li>
<li><p class="first">Modify the queens program to solve some boards of size 4, 12, and 16.  What is the
maximum size puzzle you can usually solve in under a minute?</p>
</li>
<li><p class="first">Adapt the queens program so that we keep a list of solutions that have already
printed, so that we don’t print the same solution more than once.</p>
</li>
<li><p class="first">Chess boards are symmetric: if we have a solution to the queens problem, its
mirror solution — either flipping the board on the X or in the Y axis,
is also a solution.  And giving the board a 90 degree, 180 degree, or
270 degree rotation is also a solution.  In some sense, solutions that are just
mirror images or rotations of other solutions — in the same family —
are less interesting than the unique “core cases”.   Of the 92 solutions for
the 8 queens problem, there are only 12 unique families
if you take rotations and mirror images into account.
Wikipedia has some fascinating stuff about this.</p>
<blockquote>
<div><ol class="loweralpha">
<li><p class="first">Write a function to mirror a solution in the Y axis,</p>
</li>
<li><p class="first">Write a function to mirror a solution in the X axis,</p>
</li>
<li><p class="first">Write a function to rotate a solution by 90 degrees anti-clockwise,
and use this to provide 180 and 270 degree rotations too.</p>
</li>
<li><p class="first">Write a function which is given a solution, and it generates the family of
symmetries for that solution.   For example, the symmetries of <code class="docutils literal notranslate"><span class="pre">[0,4,7,5,2,6,1,3]</span></code>
are</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">7</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span>
 <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
 <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span>
 <span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">]]</span>
</pre></div>
</div>
</li>
<li><p class="first">Now adapt the queens program so it won’t list solutions that are in the
same family.  It only prints solutions from unique families.</p>
</li>
</ol>
</div></blockquote>
</li>
<li><p class="first">Every week a computer scientist buys four lotto tickets. She always chooses the
same prime numbers, with the hope that if she ever hits the jackpot, she will be able
to go onto TV and Facebook and tell everyone her secret.  This will suddenly create widespread
public interest in prime numbers, and will be the trigger event that ushers in a new age of enlightenment.
She represents her weekly tickets in Python as a list of lists:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">my_tickets</span> <span class="o">=</span> <span class="p">[</span> <span class="p">[</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">37</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">43</span><span class="p">],</span>
               <span class="p">[</span> <span class="mi">7</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">41</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">43</span><span class="p">],</span>
               <span class="p">[</span> <span class="mi">2</span><span class="p">,</span>  <span class="mi">5</span><span class="p">,</span>  <span class="mi">7</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">17</span><span class="p">],</span>
               <span class="p">[</span><span class="mi">13</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">37</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">43</span><span class="p">]</span> <span class="p">]</span>
</pre></div>
</div>
<p>Complete these exercises.</p>
<ol class="loweralpha">
<li><p class="first">Each lotto draw takes six random balls, numbered from 1 to 49.  Write
a function to return a lotto draw.</p>
</li>
<li><p class="first">Write a function that compares a single ticket and a draw, and returns
the number of correct picks on that ticket:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">test</span><span class="p">(</span><span class="n">lotto_match</span><span class="p">([</span><span class="mi">42</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">13</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="mi">17</span><span class="p">])</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p class="first">Write a function that takes a list of tickets and a draw, and returns a list
telling how many picks were correct on each ticket:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">test</span><span class="p">(</span><span class="n">lotto_matches</span><span class="p">([</span><span class="mi">42</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">13</span><span class="p">],</span> <span class="n">my_tickets</span><span class="p">)</span> <span class="o">==</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
</li>
<li><p class="first">Write a function that takes a list of integers, and returns the number of primes in the list:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">test</span><span class="p">(</span><span class="n">primes_in</span><span class="p">([</span><span class="mi">42</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">13</span><span class="p">])</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p class="first">Write a function to discover whether the computer scientist has missed any
prime numbers in her selection of the four tickets.  Return a list of all primes that she has missed:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">test</span><span class="p">(</span><span class="n">prime_misses</span><span class="p">(</span><span class="n">my_tickets</span><span class="p">)</span> <span class="o">==</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">29</span><span class="p">,</span> <span class="mi">47</span><span class="p">])</span>
</pre></div>
</div>
</li>
<li><p class="first">Write a function that repeatedly makes a new draw, and compares the draw to the four tickets.</p>
<ol class="lowerroman simple">
<li>Count how many draws are needed until one of the computer scientist’s tickets has at least
3 correct picks.
Try the experiment twenty times, and average out the number of draws needed.</li>
<li>How many draws are needed, on average, before she gets at least 4 picks correct?</li>
<li>How many draws are needed, on average, before she gets at least 5 correct?  (Hint: this
might take a while.  It would be nice if you could print some dots, like a progress bar,
to show when each of the 20 experiments has completed.)</li>
</ol>
<p>Notice that we have difficulty constructing test cases here, because our random numbers
are not deterministic. Automated testing only really works if you already know what
the answer should be!</p>
</li>
</ol>
</li>
<li><p class="first">Read <em>Alice in Wonderland</em>.  You can read the plain text version we have with this textbook,
or if you have e-book reader software on your PC, or a Kindle, iPhone, Android, etc.
you’ll be able to find a suitable version for your device at
<a class="reference external" href="http://www.gutenberg.org/">http://www.gutenberg.org/</a>.  They also have html and pdf versions, with pictures,
and thousands of other classic books!</p>
</li>
</ol>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="classes_and_objects_I.html" title="15. Classes and Objects — the Basics"
             >next</a> |</li>
        <li class="right" >
          <a href="files.html" title="13. Files"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">How to Think Like a Computer Scientist: Learning with Python 3</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; <a href="copyright.html">Copyright</a> 2012, Peter Wentworth, Jeffrey Elkner, Allen B. Downey and Chris Meyers.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.4.
    </div>
  </body>
</html>