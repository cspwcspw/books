<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>21. Recursion &mdash; Think Sharply with C#: How to Think like a Computer Scientist</title>
    
    <link rel="stylesheet" href="_static/style.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     'Second Edition',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="Think Sharply with C#: How to Think like a Computer Scientist" href="index.html" />
    <link rel="next" title="22. Exceptions" href="exceptions.html" />
    <link rel="prev" title="20. The N-Queens Puzzle — a Case Study" href="n_queens_I.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="exceptions.html" title="22. Exceptions"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="n_queens_I.html" title="20. The N-Queens Puzzle — a Case Study"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Think Sharply with C#: How to Think like a Computer Scientist</a> &raquo;</li> 
      </ul>
    </div>

    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <div class="section" id="recursion">
<h1>21. Recursion<a class="headerlink" href="#recursion" title="Permalink to this headline">¶</a></h1>
<p><strong>Recursion</strong> means &#8220;defining something in terms of itself&#8221; usually at some
smaller scale, perhaps multiple times, to achieve your objective.
For example, we might say &#8220;A human being is someone whose mother is a human being&#8221;,
or &#8220;a directory is a structure that holds files and (smaller) directories&#8221;, or &#8220;a family tree starts
with a couple who have children, each with their own family sub-trees&#8221;.</p>
<p>So methods can <em>call themselves</em> to solve smaller sub-problems.  This idea that
the method can usefully call itself is the essence of recursion.</p>
<div class="section" id="drawing-fractals">
<span id="index-0"></span><h2>21.1. Drawing Fractals<a class="headerlink" href="#drawing-fractals" title="Permalink to this headline">¶</a></h2>
<p>For our purposes, a <strong>fractal</strong> is a recursive drawing which has <em>self-similar</em> structure.
It can be defined in terms of itself.</p>
<p>Let us start by looking at the famous Koch fractal.  An order 0 Koch fractal is simply
a straight line of a given size.</p>
<img alt="_images/koch_0.png" src="_images/koch_0.png" />
<p>An order 1 Koch fractal is obtained like this: instead of drawing just one line,
draw instead four smaller segments, in the pattern shown here:</p>
<img alt="_images/koch_1.png" src="_images/koch_1.png" />
<p>Now what would happen if we repeated this Koch pattern again on each of the order 1 segments?
We&#8217;d get this order 2 Koch fractal:</p>
<img alt="_images/koch_2.png" src="_images/koch_2.png" />
<p>Repeating our pattern again gives us an order 3 Koch fractal:</p>
<img alt="_images/koch_3.png" src="_images/koch_3.png" />
<p>Now let us think about it the other way around.  To draw a Koch fractal
of order 3, we can simply draw four order 2 Koch fractals.  But each of these
in turn needs four order 1 Koch fractals, and each of those in turn needs four
order 0 fractals.  Ultimately, the only drawing that will take place is
at order 0. This is very simple to code up in C#:</p>
<div class="highlight-csharp"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20</pre></div></td><td class="code"><div class="highlight"><pre>    <span class="k">void</span> <span class="nf">koch</span><span class="p">(</span><span class="n">Turtle</span> <span class="n">t</span><span class="p">,</span> <span class="kt">int</span> <span class="n">order</span><span class="p">,</span> <span class="kt">double</span> <span class="n">size</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// Make turtle t draw a Koch fractal of &#39;order&#39; and &#39;size&#39;.</span>
        <span class="c1">// Leave the turtle facing the same direction as it started in.</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">order</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span>
        <span class="p">{</span>   <span class="c1">// The base case is just a straight line</span>
            <span class="n">t</span><span class="p">.</span><span class="n">Forward</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>   <span class="c1">// This is the only place we draw!</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">koch</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">order</span> <span class="p">-</span> <span class="m">1</span><span class="p">,</span> <span class="n">size</span> <span class="p">/</span> <span class="m">3</span><span class="p">);</span>   <span class="c1">// Make a smaller koch drawing, 1/3 size</span>
            <span class="n">t</span><span class="p">.</span><span class="n">Left</span><span class="p">(</span><span class="m">60</span><span class="p">);</span>
            <span class="n">koch</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">order</span> <span class="p">-</span> <span class="m">1</span><span class="p">,</span> <span class="n">size</span> <span class="p">/</span> <span class="m">3</span><span class="p">);</span>
            <span class="n">t</span><span class="p">.</span><span class="n">Right</span><span class="p">(</span><span class="m">120</span><span class="p">);</span>
            <span class="n">koch</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">order</span> <span class="p">-</span> <span class="m">1</span><span class="p">,</span> <span class="n">size</span> <span class="p">/</span> <span class="m">3</span><span class="p">);</span>
            <span class="n">t</span><span class="p">.</span><span class="n">Left</span><span class="p">(</span><span class="m">60</span><span class="p">);</span>
            <span class="n">koch</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">order</span> <span class="p">-</span> <span class="m">1</span><span class="p">,</span> <span class="n">size</span> <span class="p">/</span> <span class="m">3</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>The key thing that is new here is that if order is not zero,
<code class="docutils literal"><span class="pre">koch</span></code> calls itself recursively to get its job done.</p>
<p>Whenever <code class="docutils literal"><span class="pre">koch</span></code> calls itself, it asks for a koch line of one order less
than itself.  Take some time to convince yourself that every recursive call
is a &#8220;simpler&#8221; sub-problem, and that the process must terminate.</p>
<div class="admonition-recursion-the-high-level-view admonition">
<p class="first admonition-title">Recursion, the high-level view</p>
<p>One way to think about this is to convince yourself that the method
works correctly when you call it for an order 0 fractal.  Then do
a mental <em>leap of faith</em>, saying <em>&#8220;the fairy godmother</em> (or C#, if
you can think of C# as your fairy godmother) <em>knows how to
handle the recursive order 0 calls for me on lines 12, 14, 16, and 18, so
I don&#8217;t need to think about that detail!&#8221;</em>  All I need to focus on
is how to draw an order 1 fractal <em>if I can assume the order 0 one is
already working.</em></p>
<p>You&#8217;re practising <em>mental abstraction</em> &#8212; ignoring the sub-problem
while you solve the big problem.</p>
<p>If this mode of thinking works for you (and you should practice it!), then take
it to the next level.  Aha! Now can I see that it will work when called
for order 2 <em>under the assumption that it is already working for order 1</em>.</p>
<p>And, in general, if I can use mental abstraction to gloss over how the order n-1
case works, can I just focus on solving the order n problem?</p>
<p class="last">Students of mathematics who have played with proofs of induction should
see some very strong connect-the-dots similarities here.</p>
</div>
<div class="admonition-recursion-the-low-level-operational-view admonition">
<p class="first admonition-title">Recursion, the low-level operational view</p>
<p>Another way to understand recursion is to get rid of it! If we
use separate methods to draw an order 3 fractal, an order 2 fractal, an order 1
fractal and an order 0 fractal, we could simplify the above code, quite mechanically,
to a situation where there was no longer any recursion, like this:</p>
<div class="highlight-csharp"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">void</span> <span class="nf">koch0</span><span class="p">(</span><span class="n">Turtle</span> <span class="n">t</span><span class="p">,</span> <span class="kt">double</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">t</span><span class="p">.</span><span class="n">Forward</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">void</span> <span class="nf">koch1</span><span class="p">(</span><span class="n">Turtle</span> <span class="n">t</span><span class="p">,</span> <span class="kt">double</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">koch0</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">size</span> <span class="p">/</span> <span class="m">3</span><span class="p">);</span>
    <span class="n">t</span><span class="p">.</span><span class="n">Left</span><span class="p">(</span><span class="m">60</span><span class="p">);</span>
    <span class="n">koch0</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">size</span> <span class="p">/</span> <span class="m">3</span><span class="p">);</span>
    <span class="n">t</span><span class="p">.</span><span class="n">Right</span><span class="p">(</span><span class="m">120</span><span class="p">);</span>
    <span class="n">koch0</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">size</span> <span class="p">/</span> <span class="m">3</span><span class="p">);</span>
    <span class="n">t</span><span class="p">.</span><span class="n">Left</span><span class="p">(</span><span class="m">60</span><span class="p">);</span>
    <span class="n">koch0</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">size</span> <span class="p">/</span> <span class="m">3</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">void</span> <span class="nf">koch2</span><span class="p">(</span><span class="n">Turtle</span> <span class="n">t</span><span class="p">,</span> <span class="kt">double</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">koch1</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">size</span> <span class="p">/</span> <span class="m">3</span><span class="p">);</span>
    <span class="n">t</span><span class="p">.</span><span class="n">Left</span><span class="p">(</span><span class="m">60</span><span class="p">);</span>
    <span class="n">koch1</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">size</span> <span class="p">/</span> <span class="m">3</span><span class="p">);</span>
    <span class="n">t</span><span class="p">.</span><span class="n">Right</span><span class="p">(</span><span class="m">120</span><span class="p">);</span>
    <span class="n">koch1</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">size</span> <span class="p">/</span> <span class="m">3</span><span class="p">);</span>
    <span class="n">t</span><span class="p">.</span><span class="n">Left</span><span class="p">(</span><span class="m">60</span><span class="p">);</span>
    <span class="n">koch1</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">size</span> <span class="p">/</span> <span class="m">3</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">void</span> <span class="nf">koch3</span><span class="p">(</span><span class="n">Turtle</span> <span class="n">t</span><span class="p">,</span> <span class="kt">double</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">koch2</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">size</span> <span class="p">/</span> <span class="m">3</span><span class="p">);</span>
    <span class="n">t</span><span class="p">.</span><span class="n">Left</span><span class="p">(</span><span class="m">60</span><span class="p">);</span>
    <span class="n">koch2</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">size</span> <span class="p">/</span> <span class="m">3</span><span class="p">);</span>
    <span class="n">t</span><span class="p">.</span><span class="n">Right</span><span class="p">(</span><span class="m">120</span><span class="p">);</span>
    <span class="n">koch2</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">size</span> <span class="p">/</span> <span class="m">3</span><span class="p">);</span>
    <span class="n">t</span><span class="p">.</span><span class="n">Left</span><span class="p">(</span><span class="m">60</span><span class="p">);</span>
    <span class="n">koch2</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">size</span> <span class="p">/</span> <span class="m">3</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>This trick of &#8220;unrolling&#8221; the recursion gives us an operational view
of what happens.  You can trace or single-step the program into <code class="docutils literal"><span class="pre">koch3</span></code>, and from
there, into <code class="docutils literal"><span class="pre">koch2</span></code>, and then into <code class="docutils literal"><span class="pre">koch1</span></code>, etc., all the way down
the different layers of method calls.</p>
<p>If <code class="docutils literal"><span class="pre">koch3</span></code> is called once, <code class="docutils literal"><span class="pre">koch2</span></code> will be called four times.  How many times
will <code class="docutils literal"><span class="pre">koch0</span></code> eventually be called?</p>
<p class="last">Single-stepping and taking an operational view of recursion can help build your insight.
The mental goal is, however, to be able to do the abstraction for the general case!</p>
</div>
</div>
<div class="section" id="case-study-factorials">
<h2>21.2. Case study: Factorials<a class="headerlink" href="#case-study-factorials" title="Permalink to this headline">¶</a></h2>
<p>Six factorial (written elsewhere as 6!) can easily be calculated in a loop, as 6x5x4x3x2x1.
But we can also look at this
with our recursive spectacles: N factorial is N x (N-1 factorial).  Of course, if we define
it in terms of itself we&#8217;ll need a base case too.  So we complete our recursive definition by
defining 0 factorial to be 1.   Here is a recursive value-returning method that computes factorials:</p>
<blockquote>
<div><div class="highlight-csharp"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">private</span> <span class="kt">int</span> <span class="nf">fact</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="p">&lt;=</span> <span class="m">1</span><span class="p">)</span> <span class="k">return</span> <span class="m">1</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">return</span> <span class="n">n</span> <span class="p">*</span> <span class="n">fact</span><span class="p">(</span><span class="n">n</span> <span class="p">-</span> <span class="m">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">private</span> <span class="k">void</span> <span class="nf">btnFact_Click</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">RoutedEventArgs</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="p">=</span> <span class="n">Convert</span><span class="p">.</span><span class="n">ToInt32</span><span class="p">(</span><span class="n">txtFact</span><span class="p">.</span><span class="n">Text</span><span class="p">);</span>
    <span class="n">MessageBox</span><span class="p">.</span><span class="n">Show</span><span class="p">(</span><span class="kt">string</span><span class="p">.</span><span class="n">Format</span><span class="p">(</span><span class="s">&quot;{0} factorial is {1}&quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">fact</span><span class="p">(</span><span class="n">n</span><span class="p">)));</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
</div></blockquote>
<p>When we run this a message box pops up to (correctly) tell us
that 5 factorial is 120.</p>
<p>A deck of playing cards has 52 cards (without Jokers). If we shuffle a deck, how many
possible shufflings are there? (Shuffling a deck puts the cards into a different
permutation, so the question becomes &#8220;how many permutations can we have of 52 distinct
objects?&#8221;, and the answer, of course, is 52 factorial.)</p>
<p>But when we run our program to compute 52 factorial, our program gets it wrong, with an incorrect
result of zero.</p>
<p>52! is a large number (relative to our 32-bit integers in C#) &#8212; too big to store in a <code class="docutils literal"><span class="pre">int</span></code>.
So the computation fails with what is called an <em>overflow error</em>, and fails to detect the problem.</p>
<p>We can set some options in Visual Studio for <em>overflow checking</em>, and make sure that the run-time
error is brought to our attention rather than silently ignored.  (Search the Internet
for &#8220;C# enable Overflow Checking&#8221; if you want to try this approach, but it won&#8217;t help you
to compute 52! or 1000!)</p>
<p>Often we do need to compute with big integers, especially in fields like cryptography and
problems that need us to compute 1000! exactly.  So there is a library called <code class="docutils literal"><span class="pre">System.Numerics</span></code>
that provides a structure called <code class="docutils literal"><span class="pre">BigInteger</span></code> for representing an arbitrary large signed integer.</p>
<p>We need to add a reference to our project to include the <code class="docutils literal"><span class="pre">System.Numerics</span></code> module,
and we&#8217;ll add the directive <code class="docutils literal"><span class="pre">using</span> <span class="pre">System.Numerics;</span></code> at the top of the file we&#8217;re working with.
But after that, it is really simple: all we change is the return type of the <code class="docutils literal"><span class="pre">fact</span></code> method
in line 1 above, to make the return type <code class="docutils literal"><span class="pre">BigInteger</span></code> rather than <code class="docutils literal"><span class="pre">int</span></code>.   Now we&#8217;re good
for this example:</p>
<blockquote>
<div><img alt="_images/fact1000.png" src="_images/fact1000.png" />
</div></blockquote>
</div>
<div class="section" id="case-study-fibonacci-numbers">
<span id="index-1"></span><h2>21.3. Case study: Fibonacci numbers<a class="headerlink" href="#case-study-fibonacci-numbers" title="Permalink to this headline">¶</a></h2>
<p>The famous <strong>Fibonacci sequence</strong> 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 134, ... was devised by
Fibonacci (1170-1250), who used this to model the breeding of pairs of rabbits.
If, in generation 7 you had 21 pairs in total, of which 13 were adults,
then next generation the adults will all have bred new children,
and the previous children will have grown up to become adults.
So in generation 8 you&#8217;ll have 13+21=34, of which 21 are adults.</p>
<p>This <em>model</em> to explain rabbit breeding made the simplifying assumption that rabbits never died.
Scientists often make (unrealistic) simplifying assumptions and restrictions
to make some headway with the problem.</p>
<p>If we number the terms of the sequence from 0, we can describe each term recursively
as the sum of the previous two terms:</p>
<div class="highlight-python"><div class="highlight"><pre>fib(0) = 0
fib(1) = 1
fib(n) = fib(n-1) + fib(n-2)  for n &gt;= 2
</pre></div>
</div>
<p>This translates very directly into some C#:</p>
<div class="highlight-csharp"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">using</span> <span class="nn">System.Diagnostics</span><span class="p">;</span>   <span class="c1">// for Stopwatch</span>

<span class="k">private</span> <span class="kt">int</span> <span class="nf">fib</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="p">&lt;=</span> <span class="m">1</span><span class="p">)</span> <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">t</span> <span class="p">=</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span> <span class="p">-</span> <span class="m">1</span><span class="p">)</span> <span class="p">+</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span> <span class="p">-</span> <span class="m">2</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">t</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">private</span> <span class="k">void</span> <span class="nf">btnFib_Click</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">RoutedEventArgs</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="p">=</span> <span class="n">Convert</span><span class="p">.</span><span class="n">ToInt32</span><span class="p">(</span><span class="n">txtFib</span><span class="p">.</span><span class="n">Text</span><span class="p">);</span>
    <span class="n">Stopwatch</span> <span class="n">sw</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Stopwatch</span><span class="p">();</span>
    <span class="n">sw</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="p">=</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="kt">double</span> <span class="n">elapsedSecs</span> <span class="p">=</span> <span class="p">(</span><span class="n">sw</span><span class="p">.</span><span class="n">Elapsed</span><span class="p">).</span><span class="n">TotalSeconds</span><span class="p">;</span>
    <span class="n">MessageBox</span><span class="p">.</span><span class="n">Show</span><span class="p">(</span><span class="kt">string</span><span class="p">.</span><span class="n">Format</span><span class="p">(</span><span class="s">&quot;The {0}&#39;th Fib number is {1}\nTime taken {2:F2} secs.&quot;</span><span class="p">,</span>
                                                                 <span class="n">n</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">elapsedSecs</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<blockquote>
<div><img alt="_images/fib45.png" src="_images/fib45.png" />
</div></blockquote>
<p>We get the correct result, but as we ask for more terms in the sequence we get
an exploding amount of work!  This is a particularly inefficient algorithm.
There are much better ways to compute this.</p>
</div>
<div class="section" id="debugging-and-instrumenting-recursion">
<span id="index-2"></span><h2>21.4. Debugging and instrumenting recursion<a class="headerlink" href="#debugging-and-instrumenting-recursion" title="Permalink to this headline">¶</a></h2>
<p>Suppose we wanted to know how many times <code class="docutils literal"><span class="pre">fib</span></code> had been called above, and what the maximum depth
of recursion was that had been reached.   Using class-level variables and some extra parameter information
is a handy way of arranging this:</p>
<div class="highlight-csharp"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">using</span> <span class="nn">System.Diagnostics</span><span class="p">;</span> <span class="c1">// for Stopwatch</span>

<span class="hll"><span class="kt">int</span> <span class="n">fibCallCount</span><span class="p">,</span> <span class="n">maxDepthSeen</span><span class="p">;</span>
</span>
<span class="hll"><span class="k">private</span> <span class="kt">int</span> <span class="nf">fib</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">depth</span> <span class="p">=</span> <span class="m">0</span><span class="p">)</span>
</span><span class="p">{</span>
    <span class="n">fibCallCount</span><span class="p">++;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">depth</span> <span class="p">&gt;</span> <span class="n">maxDepthSeen</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">maxDepthSeen</span> <span class="p">=</span> <span class="n">depth</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="p">&lt;=</span> <span class="m">1</span><span class="p">)</span> <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">t</span> <span class="p">=</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span> <span class="p">-</span> <span class="m">1</span><span class="p">,</span> <span class="n">depth</span> <span class="p">+</span> <span class="m">1</span><span class="p">)</span> <span class="p">+</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span> <span class="p">-</span> <span class="m">2</span><span class="p">,</span> <span class="n">depth</span> <span class="p">+</span> <span class="m">2</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">t</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">private</span> <span class="k">void</span> <span class="nf">btnFib_Click</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">RoutedEventArgs</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="p">=</span> <span class="n">Convert</span><span class="p">.</span><span class="n">ToInt32</span><span class="p">(</span><span class="n">txtFib</span><span class="p">.</span><span class="n">Text</span><span class="p">);</span>
    <span class="n">Stopwatch</span> <span class="n">sw</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Stopwatch</span><span class="p">();</span>
    <span class="n">sw</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
<span class="hll">    <span class="n">maxDepthSeen</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
</span><span class="hll">    <span class="n">fibCallCount</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
</span>    <span class="n">BigInteger</span> <span class="n">result</span> <span class="p">=</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="kt">double</span> <span class="n">elapsedSecs</span> <span class="p">=</span> <span class="p">(</span><span class="n">sw</span><span class="p">.</span><span class="n">Elapsed</span><span class="p">).</span><span class="n">TotalSeconds</span><span class="p">;</span>
    <span class="n">MessageBox</span><span class="p">.</span><span class="n">Show</span><span class="p">(</span>
        <span class="kt">string</span><span class="p">.</span><span class="n">Format</span><span class="p">(</span><span class="s">&quot;The {0}&#39;th Fib number is {1}\nTime taken {2:F2} secs.\nCalls={3} MaxDepth={4}&quot;</span><span class="p">,</span>
                      <span class="n">n</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">elapsedSecs</span><span class="p">,</span> <span class="n">fibCallCount</span><span class="p">,</span> <span class="n">maxDepthSeen</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<blockquote>
<div><img alt="_images/fib_with_instrumentation.png" src="_images/fib_with_instrumentation.png" />
</div></blockquote>
<p>Notice that the caller had to set the two class-level variables to zero at lines 20-21 before calling
<code class="docutils literal"><span class="pre">fib</span></code>.   Notice too on line 3 that depth was made an optional parameter with a default value
of zero.  So the first call to <code class="docutils literal"><span class="pre">fib</span></code> (line 22) did not supply an argument, but the recursive
calls at line 11 made sure than the value passed to the &#8220;next&#8221; recursive invocation was one more than
the depth at the current invocation.</p>
<p>Another useful mechanism is single-stepping and debugging.  In Visual Studio one can set a <em>condition</em> on
a breakpoint by right-clicking on the breakpoint, and adding a condition.  So let&#8217;s set a conditional
breakpoint at line 11 in the program above: the program should only break when <code class="docutils literal"><span class="pre">n</span> <span class="pre">==</span> <span class="pre">30</span></code>.</p>
<img alt="_images/recursion_breakpoint.png" src="_images/recursion_breakpoint.png" />
<p>The picture shows that the program has entered debugging mode at line 39.  The
Call Stack window shows the stack frames of all the recursive calls, with the most recent one at the top.
We&#8217;ve chosen one of the stack frames (with the curly green arrow at the left).  The local variable window
shows the local variables for whichever stack frame we select: in this case we&#8217;re inspecting
the values in the frame that is at depth 1 (counting from the bottom, the first <code class="docutils literal"><span class="pre">fib</span></code> frame is at depth
zero).</p>
<p>Using the debugger cleverly like this will not only help us find problems, but inspecting the
stack and the locals in each stack frame will build a solid and accurate understanding of
how our programs are executing.</p>
</div>
<div class="section" id="processing-recursive-directories-and-files">
<h2>21.5. Processing recursive directories and files<a class="headerlink" href="#processing-recursive-directories-and-files" title="Permalink to this headline">¶</a></h2>
<p>While the recursive Fibonacci and Factorial examples are interesting teaching examples
(especially if you know the typically recursive definitions from a mathematics course),
both are easier to implement without using recursion.  This section introduces a
much more compelling example &#8212; one that is much more difficult to implement if we
don&#8217;t use recursion.</p>
<p>The problem is to traverse a recursive data structure: in our case, a directory on
our disk.  The directory may recursively contain other directories and files.</p>
<p>The following program lists all the files in the directory and its sub-directories
(and of course, the sub-sub-sub directories ...)</p>
<div class="highlight-csharp"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">...</span>
<span class="k">using</span> <span class="nn">System.IO</span><span class="p">;</span>
<span class="p">...</span>

<span class="k">private</span> <span class="k">void</span> <span class="nf">btnGo_Click</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">RoutedEventArgs</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">lblHeading</span><span class="p">.</span><span class="n">Content</span> <span class="p">=</span> <span class="kt">string</span><span class="p">.</span><span class="n">Format</span><span class="p">(</span><span class="s">&quot;Folder listing of {0}\n&quot;</span><span class="p">,</span> <span class="n">txtPath</span><span class="p">.</span><span class="n">Text</span><span class="p">);</span>
    <span class="n">txtResults</span><span class="p">.</span><span class="n">Clear</span><span class="p">();</span>
    <span class="n">showFilesIn</span><span class="p">(</span><span class="n">txtPath</span><span class="p">.</span><span class="n">Text</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">private</span> <span class="k">void</span> <span class="nf">showFilesIn</span><span class="p">(</span><span class="kt">string</span> <span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
<span class="hll">    <span class="kt">string</span> <span class="p">[]</span> <span class="n">filenames</span> <span class="p">=</span> <span class="n">Directory</span><span class="p">.</span><span class="n">GetFiles</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
</span>    <span class="k">foreach</span> <span class="p">(</span><span class="kt">string</span> <span class="n">fn</span> <span class="k">in</span> <span class="n">filenames</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">txtResult</span><span class="p">.</span><span class="n">AppendText</span><span class="p">(</span><span class="n">String</span><span class="p">.</span><span class="n">Format</span><span class="p">(</span><span class="s">&quot;{0}\n&quot;</span><span class="p">,</span> <span class="n">fn</span><span class="p">));</span>
    <span class="p">}</span>

<span class="hll">    <span class="kt">string</span><span class="p">[]</span> <span class="n">subfolders</span> <span class="p">=</span> <span class="n">Directory</span><span class="p">.</span><span class="n">GetDirectories</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
</span>    <span class="k">foreach</span> <span class="p">(</span><span class="kt">string</span> <span class="n">fldr</span> <span class="k">in</span> <span class="n">subfolders</span><span class="p">)</span>
    <span class="p">{</span>
<span class="hll">        <span class="n">showFilesIn</span><span class="p">(</span><span class="n">fldr</span><span class="p">);</span>  <span class="c1">// recurse for each subfolder!</span>
</span>    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<ul class="simple">
<li>Line 14 shows how we can get the full pathnames of all the files in a given folder.
Line 20 is very similar: it gets the full pathnames of all the sub-directories.</li>
<li>The interesting recursive call occurs in line 23.</li>
</ul>
<p>With a suitable font-end GUI we could get this:</p>
<img alt="_images/directory_traversal1.png" src="_images/directory_traversal1.png" />
<div class="admonition-tip admonition">
<p class="first admonition-title">Tip:</p>
<p class="last">Recursive structures, such as directories and menu trees, are <em>much</em> easier to
process if you use a recursive algorithm.</p>
</div>
<p>Let&#8217;s take this example one or two steps further.  A nice extension is to only
list files matching a certain pattern &#8212; let&#8217;s say only the C# code-behind our GUI files.
Those all have names that end in <code class="docutils literal"><span class="pre">*.xaml.cs</span></code>.
One way to do this would be to wrap line 16 in an <code class="docutils literal"><span class="pre">if</span></code> test.
But even easier is that the <code class="docutils literal"><span class="pre">GetFiles</span></code> method in line 14
has another overloading: one that accepts a pattern, and does the filtering for us.
When searching for a string (eg. the file&#8217;s name) the asterix (*) is a special character
which allows us to return all strings starting or ending in a specific pattern as it returns
all results which contain any number and variation of characters in the place of the asterix.</p>
<p>We&#8217;ll provide a new text box on the GUI to allow the user to enter a pattern, and
use this slightly revised code:</p>
<div class="highlight-csharp"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">private</span> <span class="k">void</span> <span class="nf">btnGo_Click</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">RoutedEventArgs</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">lblHeading</span><span class="p">.</span><span class="n">Content</span> <span class="p">=</span> <span class="kt">string</span><span class="p">.</span><span class="n">Format</span><span class="p">(</span><span class="s">&quot;Folder listing of {0}\n&quot;</span><span class="p">,</span> <span class="n">txtPath</span><span class="p">.</span><span class="n">Text</span><span class="p">);</span>
    <span class="n">txtResults</span><span class="p">.</span><span class="n">Clear</span><span class="p">();</span>
<span class="hll">    <span class="n">showFilesIn</span><span class="p">(</span><span class="n">txtPath</span><span class="p">.</span><span class="n">Text</span><span class="p">,</span> <span class="n">txtPattern</span><span class="p">.</span><span class="n">Text</span><span class="p">);</span>
</span><span class="p">}</span>

<span class="hll"><span class="k">private</span> <span class="k">void</span> <span class="nf">showFilesIn</span><span class="p">(</span><span class="kt">string</span> <span class="n">path</span><span class="p">,</span> <span class="kt">string</span> <span class="n">pattern</span><span class="p">)</span>
</span><span class="p">{</span>
<span class="hll">    <span class="k">foreach</span> <span class="p">(</span><span class="kt">string</span> <span class="n">filename</span> <span class="k">in</span> <span class="n">Directory</span><span class="p">.</span><span class="n">GetFiles</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">pattern</span><span class="p">))</span> <span class="c1">//utilising overload of GetFiles</span>
</span>    <span class="p">{</span>
        <span class="n">txtResults</span><span class="p">.</span><span class="n">AppendText</span><span class="p">(</span><span class="kt">string</span><span class="p">.</span><span class="n">Format</span><span class="p">(</span><span class="s">&quot;{0}\n&quot;</span><span class="p">,</span> <span class="n">filename</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="k">foreach</span> <span class="p">(</span><span class="kt">string</span> <span class="n">foldername</span> <span class="k">in</span> <span class="n">Directory</span><span class="p">.</span><span class="n">GetDirectories</span><span class="p">(</span><span class="n">path</span><span class="p">))</span>
    <span class="p">{</span>
<span class="hll">        <span class="n">showFilesIn</span><span class="p">(</span><span class="n">foldername</span><span class="p">,</span> <span class="n">pattern</span><span class="p">);</span>
</span>    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>Notice the changes to pass the extra filtering pattern into our method, to use
the extra pattern in the call to <cite>GetFiles</cite>, and to ensure that
when we call <code class="docutils literal"><span class="pre">ShowFilesIn</span></code> recursively at line 17, we supply the extra pattern
argument to the method that must solve our subproblem.</p>
<p>Now our listing looks like this:</p>
<img alt="_images/directory_traversal2.png" src="_images/directory_traversal2.png" />
<p>In the listings above, each file name is
shown with its full path.  A more interesting idea is to just show the directory names
and file names (without the full path from C:), but to use some simple layout or extra characters
to help the user visualize the recursive folder structure.
So for the next version of this program, we want to produce output like this:</p>
<img alt="_images/directory_traversal3.png" src="_images/directory_traversal3.png" />
<p>To do this, we will output each line with a prefix string: something like &#8220;<code class="docutils literal"><span class="pre">|</span> <span class="pre">|</span> <span class="pre">|</span></code>&#8221;
that will indicate that we&#8217;re three levels deep into the structure.  In the code below,
we start on line 6 with an initial prefix <code class="docutils literal"><span class="pre">&quot;|</span> <span class="pre">&quot;</span></code>.  Then, on line 19, each time we recurse
down to a deeper level of the directory tree, we extend the existing prefix string.</p>
<p>We also use some existing magic from the built-in libraries on lines 5, 13, and 18 (the <code class="docutils literal"><span class="pre">GetFilename</span></code> method): this
call returns just the file name part of a full file path:</p>
<div class="highlight-csharp"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">private</span> <span class="k">void</span> <span class="nf">btnGo_Click</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">RoutedEventArgs</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">lblHeading</span><span class="p">.</span><span class="n">Content</span> <span class="p">=</span> <span class="kt">string</span><span class="p">.</span><span class="n">Format</span><span class="p">(</span><span class="s">&quot;Folder listing of {0}\n&quot;</span><span class="p">,</span> <span class="n">txtPath</span><span class="p">.</span><span class="n">Text</span><span class="p">);</span>
    <span class="n">txtResult</span><span class="p">.</span><span class="n">Clear</span><span class="p">();</span>
    <span class="n">txtResult</span><span class="p">.</span><span class="n">AppendText</span><span class="p">(</span><span class="kt">string</span><span class="p">.</span><span class="n">Format</span><span class="p">(</span><span class="s">&quot;*{0}\n&quot;</span><span class="p">,</span> <span class="n">Path</span><span class="p">.</span><span class="n">GetFileName</span><span class="p">(</span><span class="n">txtPath</span><span class="p">.</span><span class="n">Text</span><span class="p">)));</span>
<span class="hll">    <span class="n">showFilesAsTree</span><span class="p">(</span><span class="n">txtPath</span><span class="p">.</span><span class="n">Text</span><span class="p">,</span> <span class="n">txtPattern</span><span class="p">.</span><span class="n">Text</span><span class="p">,</span> <span class="s">&quot;| &quot;</span><span class="p">);</span>
</span><span class="p">}</span>

<span class="k">private</span> <span class="k">void</span> <span class="nf">showFilesAsTree</span><span class="p">(</span><span class="kt">string</span> <span class="n">path</span><span class="p">,</span> <span class="kt">string</span> <span class="n">pattern</span><span class="p">,</span> <span class="kt">string</span> <span class="n">prefix</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">foreach</span> <span class="p">(</span><span class="kt">string</span> <span class="n">filename</span> <span class="k">in</span> <span class="n">Directory</span><span class="p">.</span><span class="n">GetFiles</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">pattern</span><span class="p">))</span>
    <span class="p">{</span>
<span class="hll">        <span class="n">txtResult</span><span class="p">.</span><span class="n">AppendText</span><span class="p">(</span><span class="kt">string</span><span class="p">.</span><span class="n">Format</span><span class="p">(</span><span class="s">&quot;{0}-{1}\n&quot;</span><span class="p">,</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">Path</span><span class="p">.</span><span class="n">GetFileName</span><span class="p">(</span><span class="n">filename</span><span class="p">)));</span>
</span>    <span class="p">}</span>

    <span class="k">foreach</span> <span class="p">(</span><span class="kt">string</span> <span class="n">foldername</span> <span class="k">in</span> <span class="n">Directory</span><span class="p">.</span><span class="n">GetDirectories</span><span class="p">(</span><span class="n">path</span><span class="p">))</span>
    <span class="p">{</span>
<span class="hll">        <span class="n">txtResult</span><span class="p">.</span><span class="n">AppendText</span><span class="p">(</span><span class="kt">string</span><span class="p">.</span><span class="n">Format</span><span class="p">(</span><span class="s">&quot;{0}*{1}\n&quot;</span><span class="p">,</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">Path</span><span class="p">.</span><span class="n">GetFileName</span><span class="p">(</span><span class="n">foldername</span><span class="p">)));</span>
</span>        <span class="n">showFilesAsTree</span><span class="p">(</span><span class="n">foldername</span><span class="p">,</span> <span class="n">pattern</span><span class="p">,</span> <span class="n">prefix</span> <span class="p">+</span> <span class="s">&quot;| &quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="an-animated-fractal-using-our-turtle">
<span id="index-3"></span><h2>21.6. An animated fractal using our turtle<a class="headerlink" href="#an-animated-fractal-using-our-turtle" title="Permalink to this headline">¶</a></h2>
<p>Here we have a tree fractal pattern of order 8.  We&#8217;ve hand-labelled some of the edges,
showing the depth of the recursion at which each edge was drawn.</p>
<img alt="_images/recursivetree1.png" src="_images/recursivetree1.png" />
<p>In the tree above, the angle of deviation from the trunk is 30 degrees.
Varying that angle gives other interesting shapes, for example, with
the angle at 90 degrees we get this:</p>
<img alt="_images/recursivetree2.png" src="_images/recursivetree2.png" />
<p>An interesting animation occurs if we generate and draw trees very rapidly,
each time varying the angle a little.   We&#8217;ll use a timer to generate regular
tick events.  On each event, we&#8217;ll clear the previous tree and draw the new
tree from scratch.   Each tick will also change the angle slightly, to give
the animation we desire.  Let&#8217;s begin with the definition for the turtle,
and setting up of the timer.  (You can cut and paste this code into
your programming environment if you&#8217;re reading the book on-line.)</p>
<div class="highlight-csharp"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">...</span>
<span class="k">public</span> <span class="k">partial</span> <span class="k">class</span> <span class="nc">MainWindow</span> <span class="p">:</span> <span class="n">Window</span>
<span class="p">{</span>
    <span class="n">Turtle</span> <span class="n">tess</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">theta</span> <span class="p">=</span> <span class="m">90</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">MainWindow</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">InitializeComponent</span><span class="p">();</span>
        <span class="n">tess</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Turtle</span><span class="p">(</span><span class="n">playground</span><span class="p">);</span>
        <span class="n">tess</span><span class="p">.</span><span class="n">Visible</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>

        <span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Threading</span><span class="p">.</span><span class="n">DispatcherTimer</span> <span class="n">theTimer</span> <span class="p">=</span> <span class="k">new</span> <span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Threading</span><span class="p">.</span><span class="n">DispatcherTimer</span><span class="p">();</span>
        <span class="n">theTimer</span><span class="p">.</span><span class="n">Interval</span> <span class="p">=</span> <span class="n">TimeSpan</span><span class="p">.</span><span class="n">FromMilliseconds</span><span class="p">(</span><span class="m">50</span><span class="p">);</span>
        <span class="n">theTimer</span><span class="p">.</span><span class="n">IsEnabled</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
        <span class="n">theTimer</span><span class="p">.</span><span class="n">Tick</span> <span class="p">+=</span> <span class="n">dispatcherTimer_Tick</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="k">void</span> <span class="nf">dispatcherTimer_Tick</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">EventArgs</span> <span class="n">e</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">drawNextTree</span><span class="p">();</span>
    <span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>The most notable thing here is on line 14: the timer interval times the period between
the end of one tick event, and the start of the next.  So if we have processor-and-drawing
intensive work (which is the case here), this does not translate into a regular tick.
We can set the interval to zero, (or leave out line 14 completely), which means
&#8220;tick as fast as possible&#8221;.  Experiment with some different values for the timer interval.</p>
<p>Let&#8217;s consider the recursive pattern now for the tree: To draw a tree of order 0,
just draw a straight line trunk part, with no further branches or leaves.  And when
we exit the method, we&#8217;ll always ensure that the turtle is back where it started, in
the same orientation as it was in when the method was called.</p>
<p>For a tree of order greater than 0, we draw the trunk, turn for the new sub-tree,
compute the smaller sub-tree size, and recursively draw the sub-tree.  We do this
for both our left and right sub-tree.  So the code comes out like this:</p>
<div class="highlight-csharp"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">const</span> <span class="kt">double</span> <span class="n">trunk_ratio</span> <span class="p">=</span> <span class="m">0.29</span><span class="p">;</span>    <span class="c1">// The trunk length is 29% of the tree size.</span>

<span class="k">public</span> <span class="k">void</span> <span class="nf">drawTree</span><span class="p">(</span><span class="kt">int</span> <span class="n">order</span><span class="p">,</span> <span class="kt">double</span> <span class="n">theta</span><span class="p">,</span> <span class="kt">double</span> <span class="n">treeSize</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">double</span> <span class="n">trunkSize</span> <span class="p">=</span> <span class="n">treeSize</span> <span class="p">*</span> <span class="n">trunk_ratio</span><span class="p">;</span>  <span class="c1">// compute length of trunk</span>
    <span class="n">tess</span><span class="p">.</span><span class="n">Forward</span><span class="p">(</span><span class="n">trunkSize</span><span class="p">);</span>                    <span class="c1">// always draw the trunk</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">order</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">)</span>                              <span class="c1">// must we also draw subtrees?</span>
    <span class="p">{</span>
        <span class="kt">double</span> <span class="n">branchSize</span> <span class="p">=</span> <span class="n">treeSize</span> <span class="p">-</span> <span class="n">trunkSize</span><span class="p">;</span>
        <span class="n">tess</span><span class="p">.</span><span class="n">Left</span><span class="p">(</span><span class="n">theta</span><span class="p">);</span>
        <span class="n">drawTree</span><span class="p">(</span><span class="n">order</span> <span class="p">-</span> <span class="m">1</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">branchSize</span><span class="p">);</span>
        <span class="n">tess</span><span class="p">.</span><span class="n">Right</span><span class="p">(</span><span class="m">2</span> <span class="p">*</span> <span class="n">theta</span><span class="p">);</span>
        <span class="n">drawTree</span><span class="p">(</span><span class="n">order</span> <span class="p">-</span> <span class="m">1</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">branchSize</span><span class="p">);</span>
        <span class="n">tess</span><span class="p">.</span><span class="n">Left</span><span class="p">(</span><span class="n">theta</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">tess</span><span class="p">.</span><span class="n">Forward</span><span class="p">(-</span><span class="n">trunkSize</span><span class="p">);</span>    <span class="c1">// make sure we end up back where we started.</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<ul class="simple">
<li>Lines 11,13 and 15 ensure that whatever heading the turtle started at will be its final heading too.</li>
<li>Line 18 puts the turtle back where it began, by &#8220;undoing&#8221; the movement from line 6.</li>
<li>The all-important recursive calls on line 12 and 14 decrease the order at the next level, and
decrease the overall remaining size to be drawn.</li>
</ul>
<p>So what is left: we need to handle the timer tick, clear the old drawing,
draw the new tree, and change our class-level variable <code class="docutils literal"><span class="pre">theta</span></code>.  So the final
piece of the puzzle is this:</p>
<div class="highlight-csharp"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">private</span> <span class="k">void</span> <span class="nf">drawNextTree</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">tess</span><span class="p">.</span><span class="n">Clear</span><span class="p">();</span>
    <span class="n">tess</span><span class="p">.</span><span class="n">BatchSize</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
    <span class="n">tess</span><span class="p">.</span><span class="n">WarpTo</span><span class="p">(</span><span class="n">playground</span><span class="p">.</span><span class="n">ActualWidth</span> <span class="p">/</span> <span class="m">2</span><span class="p">,</span> <span class="n">playground</span><span class="p">.</span><span class="n">ActualHeight</span> <span class="p">-</span> <span class="m">10</span><span class="p">);</span>
    <span class="n">tess</span><span class="p">.</span><span class="n">Heading</span> <span class="p">=</span> <span class="p">-</span><span class="m">90</span><span class="p">;</span>
    <span class="n">drawTree</span><span class="p">(</span><span class="m">7</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">playground</span><span class="p">.</span><span class="n">ActualHeight</span> <span class="p">-</span> <span class="m">10</span><span class="p">);</span>

    <span class="n">theta</span> <span class="p">+=</span> <span class="m">5</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<ul class="simple">
<li>Lines 5 and 7 show that we can make the tree size and the starting position for the
turtle depend on the playground size.  If your playground stretches as your window resizes,
the tree will grow bigger or smaller.</li>
<li>Line 4 needs some explanation. When the turtle &#8220;draws&#8221; it constructs new WPF
controls - mainly line segments. In it&#8217;s default setting, the turtle forces our screen to
refresh after each new line segment is created.  This one-at-a-time refreshing
can be very slow if there are many line segments in our drawing.  Setting the
batch size of the turtle to zero means &#8220;do not refresh the screen until all the current
computation finishes&#8221;.
It means we&#8217;ll show the whole tree at once, and things will be much faster.  Try commenting
out line 4 and see the difference.</li>
</ul>
</div>
<div class="section" id="glossary">
<h2>21.7. Glossary<a class="headerlink" href="#glossary" title="Permalink to this headline">¶</a></h2>
<dl class="glossary docutils">
<dt id="term-base-case">base case</dt>
<dd>A branch of the conditional statement in a recursive method that does
not give rise to further recursive calls.</dd>
<dt id="term-infinite-recursion">infinite recursion</dt>
<dd>A method that calls itself recursively without ever reaching any base
case. Eventually, infinite recursion causes a runtime error.</dd>
<dt id="term-recursion">recursion</dt>
<dd>The process of calling a method that is already executing.</dd>
<dt id="term-recursive-call">recursive call</dt>
<dd>The statement that calls an already executing method.  Recursion can
also be indirect &#8212; method <cite>f</cite> can call <cite>g</cite> which calls <cite>h</cite>,
and <cite>h</cite> could make a call back to <cite>f</cite>.</dd>
<dt id="term-recursive-definition">recursive definition</dt>
<dd>A definition which defines something in terms of itself. To be useful
it must include <em>base cases</em> which are not recursive. In this way it
differs from a <em>circular definition</em>.  Recursive definitions often
provide an elegant way to express complex data structures, like a directory
that can contain other directories, or a menu that can contain other menus.</dd>
</dl>
</div>
<div class="section" id="exercises">
<h2>21.8. Exercises<a class="headerlink" href="#exercises" title="Permalink to this headline">¶</a></h2>
<ol class="arabic">
<li><p class="first">Change a small recursive program from this chapter so that the base case test
is never satisfied.  Run it and see what happens.  Can you make sense of
the error message, and recognize it in future?</p>
</li>
<li><p class="first">Modify the Koch fractal program so that it draws a Koch snowflake, like this:</p>
<img alt="_images/koch_snowflake.png" src="_images/koch_snowflake.png" />
<div class="line-block">
<div class="line"><br /></div>
</div>
</li>
<li id="index-4"><ol class="first loweralpha">
<li><p class="first">Draw a Cesaro torn line fractal, of the order given by the user.
We show four different lines of orders 0,1,2,3.
In this example, the angle of the tear is 10 degrees.</p>
<img alt="_images/cesaro_torn_line.png" src="_images/cesaro_torn_line.png" />
</li>
<li><p class="first">Four lines make a square.  Use the code in part a) to draw Cesaro squares.
Varying the angle gives interesting effects &#8212; experiment a bit,
or perhaps let the user input the angle of the tear.</p>
<img alt="_images/cesaro_torn_square.png" src="_images/cesaro_torn_square.png" />
</li>
</ol>
<ol class="loweralpha simple" id="index-5" start="3">
<li>(For the mathematically inclined). In the squares shown here, the higher-order drawings
become a little larger. (Look at the bottom lines of each square - they&#8217;re not aligned.)
This is because we just halved the drawn part of the line for each recursive sub-problem.
So we&#8217;ve &#8220;grown&#8221; the overall square by the width of the tear(s).
Can you solve the geometry problem so that the total size of the sub-problem case
(including the tear) remains exactly the same size as the original?</li>
</ol>
<div class="line-block">
<div class="line"><br /></div>
</div>
</li>
<li><p class="first">A Sierpinski triangle of order 0 is an equilateral triangle.
An order 1 triangle can be drawn by drawing 3 smaller triangles
(shown slightly disconnected here, just to help our understanding).
Higher order 2 and 3 triangles are also shown.
Draw Sierpinski triangles of any order input by the user.</p>
<img alt="_images/sierpinski.png" src="_images/sierpinski.png" />
</li>
<li><p class="first">Adapt the above program to change the brush colour of its three sub-triangles at some depth
of recursion. The illustration below shows two cases: on the left, the colour is changed at depth 0
(the outermost level of recursion), on the right, at depth 2. If the user supplies a negative
depth, the colour never changes.
(Hint: add a new optional parameter <code class="docutils literal"><span class="pre">colourChangeDepth</span></code> (which defaults to -1), and make this one
smaller on each recursive sub-call. Then, in the section of code before you recurse, test
whether the parameter is zero, and change color.)</p>
<img alt="_images/sierpinski_color.png" src="_images/sierpinski_color.png" />
</li>
<li><p class="first">(Pretty challenging problem, but solvable.)
A woodworker uses a CNC (computer numerical controlled)
machine to carve a Sierpinski triangle into a
piece of wood. However, the cleanest cuts occur
if the cutting bit (i.e. tess&#8217; pen)
is never lifted, and never goes over the same line more than once.</p>
<img alt="_images/sierpinski_woodcarve.jpg" src="_images/sierpinski_woodcarve.jpg" />
<ol class="loweralpha simple">
<li>By hand, draw a Sierpinski triangle of order 2 such that you never lift your pen,
and never go over any line more than once.  (Ignore the Smiley!)</li>
<li>Program your turtle to do the same for any order Sierpinski triangle.</li>
</ol>
</li>
<li><p class="first">Rewrite the Fibonacci algorithm without using recursion.  Make use of the BigInteger
type that was introduced in the <code class="docutils literal"><span class="pre">factorial</span></code> section.
Find <code class="docutils literal"><span class="pre">fib(200)</span></code>.</p>
</li>
<li><p class="first">10! has two trailing zeros. 20! has four trailing zeros. But 30! has 7 trailing
zeros, which is not what you might have guessed!  Explain where these trailing
zeros are coming from, and what is special about the range between 20! and 30!
(Hint: Count and display the trailing zeros to allow you to easily investigate
the problem.)</p>
</li>
<li><p class="first">Modify our program that traverses a directory structure.
Instead of outputting file names, it returns a list of all
the full paths of files in the directory or the subdirectories.  (Don&#8217;t include
directories in this list &#8212; just the files.)  For example, the output list might
have elements like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="s">&quot;C:</span><span class="se">\t</span><span class="s">emp\Clock.zip&quot;</span><span class="p">,</span> <span class="s">&quot;C:</span><span class="se">\t</span><span class="s">emp\Pie.zip&quot;</span><span class="p">,</span> <span class="s">&quot;C:</span><span class="se">\t</span><span class="s">emp\ThinkLib.dll&quot;</span><span class="p">,</span>  <span class="o">...</span> <span class="p">]</span>
</pre></div>
</div>
</li>
<li><p class="first">Write a method named <code class="docutils literal"><span class="pre">litter</span></code> that creates an empty file named
<code class="docutils literal"><span class="pre">trash.txt</span></code> in each subdirectory of a given directory tree.
<em>Hint:</em> Use <code class="docutils literal"><span class="pre">File.Create</span></code> to create a file.</p>
</li>
<li><p class="first">Now write a method named <code class="docutils literal"><span class="pre">cleanup</span></code> that removes all the litter files.</p>
<p><em>Hint 1:</em> Use the directory lister program from this
chapter as a basis for these recursive programs.  Because you&#8217;re
going to destroy files on your disks, you had better get this right, or
you risk losing files you care about.  So excellent advice is that
initially you should fake the deletion of the files &#8212; just output
the full path names of each file that you intend to delete.  Once
you&#8217;re happy that your logic is correct, and you can see that you&#8217;re
not deleting the wrong things, you can put the real code in place.</p>
<p><em>Hint 2:</em> Use <code class="docutils literal"><span class="pre">File.Delete</span></code> to remove a file.</p>
</li>
</ol>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="exceptions.html" title="22. Exceptions"
             >next</a> |</li>
        <li class="right" >
          <a href="n_queens_I.html" title="20. The N-Queens Puzzle — a Case Study"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Think Sharply with C#: How to Think like a Computer Scientist</a> &raquo;</li> 
      </ul>
    </div> 
  <div class="footer"> 
   <span class="creativecommons"> 
    <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/" > 
      <img src="_static/creativecommons-88x31.png" 
           border="0" alt="Creative Commons License"/> 
     </a> 
    Licensed under a 
    <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/"> 
    Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License. 
    </a> 
   </span> 
  </div>
  </body>
</html>